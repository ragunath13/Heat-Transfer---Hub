<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Forced Circulation Evaporator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif; /* Using Inter font */
            color: #ffffff; /* Pure white for better visibility */
        }
        canvas {
            display: block;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #ffffff; /* Ensure info panel text is pure white */
            padding: 15px;
            border-radius: 8px; /* Rounded corners */
            max-width: 600px;
            text-align: center;
            transition: all 0.5s ease;
            z-index: 100;
            border: 1px solid #2196f3; /* Blue border for forced circulation theme */
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.2); /* Blue shadow */
        }
        .info-panel h3 {
            margin-top: 0;
            color: #90caf9; /* Lighter blue for info panel title */
            font-size: 22px;
        }
        .info-panel p {
            margin-bottom: 0;
            font-size: 16px;
            line-height: 1.5;
        }
        #title {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: #ffffff; /* Ensure main title is pure white */
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            z-index: 100;
            border-radius: 8px; /* Rounded corners */
        }
        #controls {
            position: absolute;
            top: 70px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            background-color: rgba(0, 0, 0, 0.9); /* Increased opacity */
            color: #ffffff; /* Ensure button text is pure white */
            border: 2px solid #2196f3; /* Thicker blue border */
            padding: 8px 12px;
            border-radius: 4px; /* Rounded corners */
            cursor: pointer;
            min-width: 180px; /* Increased width for better text display */
            text-align: left;
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 10px rgba(33, 150, 243, 0.3); /* More prominent shadow */
        }
        button:hover {
            background-color: rgba(33, 150, 243, 0.3); /* Lighter blue on hover */
            border-color: #90caf9; /* Lighter border on hover */
            box-shadow: 0 6px 15px rgba(33, 150, 243, 0.4); /* Enhanced shadow on hover */
        }
        .component-button {
            display: flex;
            align-items: center;
        }
        .component-button .color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            display: inline-block;
            border: 1px solid rgba(255, 255, 255, 0.3); /* Small border for visibility */
        }
    </style>
</head>
<body>
    <div id="title">Forced Circulation Evaporator - Click on any component</div>
    <div id="controls">
        <button id="reset-view">Show Full Assembly</button>
        <button id="section-view">Section View</button>
        <div style="margin-top: 10px; color: #ffffff; font-size: 14px;">Component Quick View:</div>
        <button id="view-vapor-liquid-separator"><span class="color-indicator" style="background-color: #2196f3;"></span>View Vapor-Liquid Separator</button>
        <button id="view-calandria"><span class="color-indicator" style="background-color: #1976d2;"></span>View Calandria</button>
        <button id="view-circulation-pump"><span class="color-indicator" style="background-color: #757575;"></span>View Circulation Pump</button>
        <button id="view-liquid-inlet"><span class="color-indicator" style="background-color: #8bc34a;"></span>View Liquid Inlet</button>
        <button id="view-vapor-outlet"><span class="color-indicator" style="background-color: #bbdefb;"></span>View Vapor Outlet</button>
        <button id="view-concentrate-outlet"><span class="color-indicator" style="background-color: #d32f2f;"></span>View Concentrate Outlet</button>
        <button id="view-heating-medium-io"><span class="color-indicator" style="background-color: #ff9800;"></span>View Heating Medium I/O</button>
    </div>
    <div id="info-panel" class="info-panel" style="display: none;">
        <h3 id="component-title">Component</h3>
        <p id="component-description">Description will appear here</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/curves/CatmullRomCurve3.js"></script>
    <script>
        // Main Three.js variables
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Black background

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(30, 25, 40); // Initial camera position, adjusted for new layout
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        document.body.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth camera movement
        controls.dampingFactor = 0.05;
        controls.target.set(0, 10, 0); // Point camera towards the center of the evaporator
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Soft ambient light
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Main light source
        directionalLight.position.set(10, 50, 20); // Positioned above and to the side
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 150;
        directionalLight.shadow.camera.left = -60;
        directionalLight.shadow.camera.right = 60;
        directionalLight.shadow.camera.top = 60;
        directionalLight.shadow.camera.bottom = -60;
        scene.add(directionalLight);
        
        const backLight = new THREE.DirectionalLight(0xffffff, 0.3); // Secondary light
        backLight.position.set(-10, -50, -20);
        scene.add(backLight);
        
        // Interaction tools
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Animation variables
        let animationId = null;
        let targetPosition = null;
        let targetLookAt = null;
        let isAnimating = false;
        
        // Section view
        let isSectionView = false;
        // Section plane for cutting through the model (initially cutting along XZ plane)
        const sectionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); 
        const sectionHelper = new THREE.PlaneHelper(sectionPlane, 20, 0xff0000); // Red helper plane
        sectionHelper.visible = false;
        scene.add(sectionHelper);
        renderer.localClippingEnabled = false; // Disable clipping by default

        // Component storage
        const components = {
            vaporLiquidSeparator: null,
            calandriaShell: null,
            calandriaTubes: null,
            circulationPump: null,
            liquidInlet: null,
            vaporOutlet: null,
            concentrateOutlet: null,
            heatingMediumIO: null,
            pipeFromSeparatorToPump: null,
            pipeFromPumpToCalandria: null,
            pipeFromCalandriaToSeparator: null,
            fluidFlowFeed: null,
            fluidFlowCirculation: null,
            fluidFlowVapor: null,
            fluidFlowConcentrate: null,
            fluidFlowHeatingMedium: null,
            fullAssembly: null
        };
        
        // Component information (descriptions, colors, etc.)
        const componentInfo = {
            'vaporLiquidSeparator': {
                title: 'Vapor-Liquid Separator',
                description: 'A large vessel where the flashed vapor separates from the concentrated liquid after leaving the calandria.',
                color: 0x2196f3, // Blue
                internal: false
            },
            'calandria': {
                title: 'Calandria (Heat Exchanger)',
                description: 'An external shell and tube heat exchanger where the circulating liquid is heated, but boiling is suppressed due to hydrostatic pressure.',
                color: 0x1976d2, // Darker Blue
                internal: true
            },
            'circulationPump': {
                title: 'Circulation Pump',
                description: 'A pump that forces the liquid from the separator through the calandria and back into the separator, ensuring high circulation rates.',
                color: 0x757575, // Grey
                internal: false
            },
            'liquidInlet': {
                title: 'Liquid Feed Inlet',
                description: 'The nozzle or pipe connection through which the dilute liquid feed enters the circulation loop, typically before the pump or separator.',
                color: 0x8bc34a, // Light Green
                internal: false
            },
            'vaporOutlet': {
                title: 'Vapor Outlet',
                description: 'The connection at the top of the vapor-liquid separator for the removal of the generated vapor.',
                color: 0xbbdefb, // Lighter Blue
                internal: false
            },
            'concentrateOutlet': {
                title: 'Concentrate Outlet',
                description: 'The nozzle or pipe connection at the bottom of the vapor-liquid separator for discharging the concentrated liquid product.',
                color: 0xd32f2f, // Dark Red
                internal: false
            },
            'heatingMediumIO': {
                title: 'Heating Medium Inlet/Outlet',
                description: 'Connections on the calandria shell for the entry and exit of the heating medium (e.g., steam in, condensate out) that provides heat for evaporation.',
                color: 0xff9800, // Orange
                internal: false
            }
        };

        // Global constants for evaporator dimensions
        const separatorRadius = 6;
        const separatorHeight = 20;

        const calandriaRadius = 4;
        const calandriaHeight = 15;
        const calandriaOffset = 10; // Offset from separator center

        const pumpRadius = 2;
        const pumpHeight = 3;

        const tubeRadius = 0.1;
        const numTubeRows = 8;
        const numTubeCols = 8;
        const tubeSpacing = 0.7;
        const tubeLength = calandriaHeight - 1;

        const pipeRadius = 0.5;
        const nozzleRadius = 1.2;
        const nozzleLength = 3;

        // Global constants for fluid particles
        const particleSizeFeed = 0.2;
        const particleSizeCirculation = 0.15;
        const particleSizeVapor = 0.25;
        const particleSizeConcentrate = 0.2;
        const particleSizeHeatingMedium = 0.2;


        // Create all components of the forced circulation evaporator
        function createComponents() {
            // Overall Evaporator Group (for positioning)
            const evaporatorGroup = new THREE.Group();
            // Position the entire evaporator so its base is around Y=0
            const totalHeight = separatorHeight + calandriaHeight + pumpHeight; // Approximate
            evaporatorGroup.position.y = totalHeight / 2 - 5; // Adjust to center vertically

            // Vapor-Liquid Separator
            const separatorMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.vaporLiquidSeparator.color,
                metalness: 0.7,
                roughness: 0.3,
                transparent: true,
                opacity: 0.7,
                clearcoat: 0.5,
                side: THREE.DoubleSide
            });
            components.vaporLiquidSeparator = new THREE.Mesh(
                new THREE.CylinderGeometry(separatorRadius, separatorRadius, separatorHeight, 32),
                separatorMaterial
            );
            components.vaporLiquidSeparator.position.y = separatorHeight / 2 + 5; // Elevated
            components.vaporLiquidSeparator.userData = { type: 'vaporLiquidSeparator' };
            evaporatorGroup.add(components.vaporLiquidSeparator);

            // Calandria Shell (external heat exchanger)
            const calandriaShellMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.calandria.color,
                metalness: 0.7,
                roughness: 0.3,
                transparent: true,
                opacity: 0.7,
                clearcoat: 0.5,
                side: THREE.DoubleSide
            });
            components.calandriaShell = new THREE.Mesh(
                new THREE.CylinderGeometry(calandriaRadius, calandriaRadius, calandriaHeight, 32),
                calandriaShellMaterial
            );
            components.calandriaShell.position.set(calandriaOffset, calandriaHeight / 2, 0);
            components.calandriaShell.userData = { type: 'calandria' };
            evaporatorGroup.add(components.calandriaShell);

            // Calandria Tubes (inner tubes of the heat exchanger)
            components.calandriaTubes = new THREE.Group();
            const tubeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x81d4fa, // Light blue for tubes
                metalness: 0.5,
                roughness: 0.5
            });

            const offset = (numTubeRows - 1) * tubeSpacing / 2;
            for (let i = 0; i < numTubeRows; i++) {
                for (let j = 0; j < numTubeCols; j++) {
                    const xPos = (i * tubeSpacing) - offset;
                    const zPos = (j * tubeSpacing) - offset;

                    if (Math.sqrt(xPos * xPos + zPos * zPos) < calandriaRadius - tubeRadius - 0.5) {
                        const tube = new THREE.Mesh(
                            new THREE.CylinderGeometry(tubeRadius, tubeRadius, tubeLength, 16),
                            tubeMaterial
                        );
                        tube.position.set(xPos + calandriaOffset, calandriaHeight / 2, zPos);
                        tube.userData = { type: 'calandria' };
                        components.calandriaTubes.add(tube);
                    }
                }
            }
            evaporatorGroup.add(components.calandriaTubes);

            // Circulation Pump
            const pumpMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.circulationPump.color,
                metalness: 0.8,
                roughness: 0.2
            });
            components.circulationPump = new THREE.Mesh(
                new THREE.CylinderGeometry(pumpRadius, pumpRadius, pumpHeight, 32),
                pumpMaterial
            );
            components.circulationPump.position.set(0, -pumpHeight / 2, 0); // Below separator
            components.circulationPump.userData = { type: 'circulationPump' };
            evaporatorGroup.add(components.circulationPump);

            // Liquid Feed Inlet
            const liquidInletMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.liquidInlet.color,
                metalness: 0.6,
                roughness: 0.4
            });
            components.liquidInlet = new THREE.Mesh(
                new THREE.CylinderGeometry(nozzleRadius * 0.8, nozzleRadius * 0.8, nozzleLength, 16),
                liquidInletMaterial
            );
            components.liquidInlet.rotation.x = Math.PI / 2;
            components.liquidInlet.position.set(-separatorRadius - nozzleLength / 2, -pumpHeight * 0.5, 0); // Into the circulation loop
            components.liquidInlet.userData = { type: 'liquidInlet' };
            evaporatorGroup.add(components.liquidInlet);

            // Vapor Outlet
            const vaporOutletMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.vaporOutlet.color,
                metalness: 0.6,
                roughness: 0.4
            });
            components.vaporOutlet = new THREE.Mesh(
                new THREE.CylinderGeometry(nozzleRadius * 1.2, nozzleRadius * 1.2, nozzleLength, 16),
                vaporOutletMaterial
            );
            components.vaporOutlet.position.set(0, separatorHeight + 5 + nozzleLength / 2, 0); // Top of separator
            components.vaporOutlet.userData = { type: 'vaporOutlet' };
            evaporatorGroup.add(components.vaporOutlet);

            // Concentrate Outlet
            const concentrateOutletMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.concentrateOutlet.color,
                metalness: 0.6,
                roughness: 0.4
            });
            components.concentrateOutlet = new THREE.Mesh(
                new THREE.CylinderGeometry(nozzleRadius * 0.7, nozzleRadius * 0.7, nozzleLength, 16),
                concentrateOutletMaterial
            );
            components.concentrateOutlet.rotation.x = Math.PI / 2;
            components.concentrateOutlet.position.set(separatorRadius + nozzleLength / 2, -separatorHeight / 2 + 5, 0); // Side of separator bottom
            components.concentrateOutlet.userData = { type: 'concentrateOutlet' };
            evaporatorGroup.add(components.concentrateOutlet);

            // Heating Medium Inlet/Outlet
            const heatingMediumMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.heatingMediumIO.color,
                metalness: 0.6,
                roughness: 0.4
            });
            components.heatingMediumIO = new THREE.Group();
            const heatingInlet = new THREE.Mesh(
                new THREE.CylinderGeometry(nozzleRadius * 0.6, nozzleRadius * 0.6, nozzleLength, 16),
                heatingMediumMaterial
            );
            heatingInlet.rotation.z = Math.PI / 2;
            heatingInlet.position.set(calandriaOffset + calandriaRadius + nozzleLength / 2, calandriaHeight / 4, 0);
            heatingInlet.userData = { type: 'heatingMediumIO' };
            components.heatingMediumIO.add(heatingInlet);

            const heatingOutlet = heatingInlet.clone();
            heatingOutlet.position.y = -calandriaHeight / 4;
            components.heatingMediumIO.add(heatingOutlet);
            evaporatorGroup.add(components.heatingMediumIO);

            // Circulation Pipes
            const pipeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x9e9e9e, // Grey for pipes
                metalness: 0.6,
                roughness: 0.4
            });

            // Pipe from Separator to Pump
            const path1Points = [
                new THREE.Vector3(0, 5 - separatorHeight / 2, 0), // Bottom of separator
                new THREE.Vector3(0, -pumpHeight / 2 + pumpRadius, 0) // Top of pump
            ];
            const curve1 = new THREE.CatmullRomCurve3(path1Points);
            const tubeGeometry1 = new THREE.TubeGeometry(curve1, 20, pipeRadius, 8, false);
            components.pipeFromSeparatorToPump = new THREE.Mesh(tubeGeometry1, pipeMaterial);
            components.pipeFromSeparatorToPump.userData = { type: 'circulationPipe' };
            evaporatorGroup.add(components.pipeFromSeparatorToPump);

            // Pipe from Pump to Calandria
            const path2Points = [
                new THREE.Vector3(0, -pumpHeight / 2, 0), // Bottom of pump
                new THREE.Vector3(0, -pumpHeight / 2 - 5, 0), // Down
                new THREE.Vector3(calandriaOffset, -pumpHeight / 2 - 5, 0), // Across to calandria level
                new THREE.Vector3(calandriaOffset, -calandriaHeight / 2 + pipeRadius, 0) // Up to calandria inlet
            ];
            const curve2 = new THREE.CatmullRomCurve3(path2Points);
            const tubeGeometry2 = new THREE.TubeGeometry(curve2, 40, pipeRadius, 8, false);
            components.pipeFromPumpToCalandria = new THREE.Mesh(tubeGeometry2, pipeMaterial);
            components.pipeFromPumpToCalandria.userData = { type: 'circulationPipe' };
            evaporatorGroup.add(components.pipeFromPumpToCalandria);

            // Pipe from Calandria to Separator
            const path3Points = [
                new THREE.Vector3(calandriaOffset, calandriaHeight / 2 - pipeRadius, 0), // Top of calandria
                new THREE.Vector3(calandriaOffset, separatorHeight + 5, 0), // Up to separator level
                new THREE.Vector3(separatorRadius - pipeRadius, separatorHeight + 5, 0) // Across to separator inlet
            ];
            const curve3 = new THREE.CatmullRomCurve3(path3Points);
            const tubeGeometry3 = new THREE.TubeGeometry(curve3, 40, pipeRadius, 8, false);
            components.pipeFromCalandriaToSeparator = new THREE.Mesh(tubeGeometry3, pipeMaterial);
            components.pipeFromCalandriaToSeparator.userData = { type: 'circulationPipe' };
            evaporatorGroup.add(components.pipeFromCalandriaToSeparator);


            // Fluid Flow Animation
            components.fluidFlowFeed = new THREE.Group();
            components.fluidFlowCirculation = new THREE.Group();
            components.fluidFlowVapor = new THREE.Group();
            components.fluidFlowConcentrate = new THREE.Group();
            components.fluidFlowHeatingMedium = new THREE.Group();

            const feedColor = 0x8bc34a; // Light Green for feed
            const circulationColor = 0x64b5f6; // Light Blue for circulation
            const vaporColor = 0xe3f2fd; // Very Light Blue for vapor
            const concentrateColor = 0xd32f2f; // Dark Red for concentrate
            const heatingMediumColor = 0xffa726; // Orange for heating medium

            function createFluidParticles(color, numParticles, size) {
                const positions = new Float32Array(numParticles * 3);
                const particles = new THREE.BufferAttribute(positions, 3);
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', particles);

                const material = new THREE.PointsMaterial({
                    color: color,
                    size: size,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.7,
                    sizeAttenuation: true
                });

                const points = new THREE.Points(geometry, material);
                points.userData.progress = new Array(numParticles).fill(0).map(() => Math.random()); // Random initial progress
                return points;
            }

            // Feed Flow (into circulation loop)
            const feedParticles = createFluidParticles(feedColor, 30, particleSizeFeed);
            feedParticles.userData.paths = [];
            const feedPathPoints = [
                components.liquidInlet.position.clone().add(new THREE.Vector3(nozzleLength / 2, 0, 0)),
                new THREE.Vector3(-pipeRadius, -pumpHeight / 2 + pumpRadius, 0) // Towards pump inlet
            ];
            feedParticles.userData.paths.push(new THREE.CatmullRomCurve3(feedPathPoints));
            components.fluidFlowFeed.add(feedParticles);
            evaporatorGroup.add(components.fluidFlowFeed);

            // Circulation Flow (through pump, calandria, to separator)
            const circulationParticles = createFluidParticles(circulationColor, 300, particleSizeCirculation);
            circulationParticles.userData.paths = [];
            const circulationPathPoints = [
                new THREE.Vector3(0, 5 - separatorHeight / 2, 0), // Start from separator bottom
                new THREE.Vector3(0, -pumpHeight / 2 + pumpRadius, 0), // To pump
                new THREE.Vector3(0, -pumpHeight / 2, 0), // From pump
                new THREE.Vector3(0, -pumpHeight / 2 - 5, 0), // Down
                new THREE.Vector3(calandriaOffset, -pumpHeight / 2 - 5, 0), // Across
                new THREE.Vector3(calandriaOffset, -calandriaHeight / 2 + pipeRadius, 0), // Into calandria
                new THREE.Vector3(calandriaOffset, calandriaHeight / 2 - pipeRadius, 0), // Through calandria
                new THREE.Vector3(calandriaOffset, separatorHeight + 5, 0), // Up
                new THREE.Vector3(separatorRadius - pipeRadius, separatorHeight + 5, 0), // Into separator
                new THREE.Vector3(separatorRadius - 0.5, separatorHeight + 5 - 2, 0) // Inside separator
            ];
            circulationParticles.userData.paths.push(new THREE.CatmullRomCurve3(circulationPathPoints));
            components.fluidFlowCirculation.add(circulationParticles);
            evaporatorGroup.add(components.fluidFlowCirculation);

            // Vapor Flow (rising in separator, exiting)
            const vaporParticles = createFluidParticles(vaporColor, 150, particleSizeVapor);
            vaporParticles.userData.paths = [];
            const vaporPathPoints = [
                new THREE.Vector3(0, separatorHeight / 2 + 5, 0), // From liquid surface in separator
                components.vaporOutlet.position.clone().add(new THREE.Vector3(0, -nozzleLength / 2, 0))
            ];
            vaporParticles.userData.paths.push(new THREE.CatmullRomCurve3(vaporPathPoints));
            components.fluidFlowVapor.add(vaporParticles);
            evaporatorGroup.add(components.fluidFlowVapor);

            // Concentrate Flow (exiting separator)
            const concentrateParticles = createFluidParticles(concentrateColor, 75, particleSizeConcentrate);
            concentrateParticles.userData.paths = [];
            const concentratePathPoints = [
                new THREE.Vector3(separatorRadius - 0.5, -separatorHeight / 2 + 5, 0), // From bottom of separator
                components.concentrateOutlet.position.clone().add(new THREE.Vector3(-nozzleLength / 2, 0, 0))
            ];
            concentrateParticles.userData.paths.push(new THREE.CatmullRomCurve3(concentratePathPoints));
            components.fluidFlowConcentrate.add(concentrateParticles);
            evaporatorGroup.add(components.fluidFlowConcentrate);

            // Heating Medium Flow (through calandria shell)
            const heatingMediumParticles = createFluidParticles(heatingMediumColor, 100, particleSizeHeatingMedium);
            heatingMediumParticles.userData.paths = [];
            const heatingPathPoints = [
                components.heatingMediumIO.children[0].position.clone().add(new THREE.Vector3(-nozzleLength / 2, 0, 0)), // Inlet
                new THREE.Vector3(calandriaOffset + calandriaRadius * 0.8, calandriaHeight / 4, calandriaRadius * 0.5),
                new THREE.Vector3(calandriaOffset + calandriaRadius * 0.8, -calandriaHeight / 4, -calandriaRadius * 0.5),
                components.heatingMediumIO.children[1].position.clone().add(new THREE.Vector3(nozzleLength / 2, 0, 0)) // Outlet
            ];
            heatingMediumParticles.userData.paths.push(new THREE.CatmullRomCurve3(heatingPathPoints));
            components.fluidFlowHeatingMedium.add(heatingMediumParticles);
            evaporatorGroup.add(components.fluidFlowHeatingMedium);


            // Add all fluid flows to the scene, initially hidden
            components.fluidFlowFeed.visible = false;
            components.fluidFlowCirculation.visible = false;
            components.fluidFlowVapor.visible = false;
            components.fluidFlowConcentrate.visible = false;
            components.fluidFlowHeatingMedium.visible = false;

            // Full assembly
            components.fullAssembly = evaporatorGroup; // The main group is the full assembly
            scene.add(components.fullAssembly);
        }

        // Initialize components
        createComponents();

        // Show only specific component(s)
        function showOnly(componentType) {
            // Hide all components first
            Object.values(components).forEach(comp => {
                // Exclude fluid flows and the main fullAssembly group from being hidden individually
                if (comp && comp !== components.fullAssembly && 
                    !comp.userData.isFluidFlow) { // Assuming fluid flows will have this userData
                    comp.visible = false;
                }
            });
            
            // Hide fluid animations by default when changing views, unless explicitly shown
            components.fluidFlowFeed.visible = false;
            components.fluidFlowCirculation.visible = false;
            components.fluidFlowVapor.visible = false;
            components.fluidFlowConcentrate.visible = false;
            components.fluidFlowHeatingMedium.visible = false;

            // Show the requested component(s) and relevant context
            if (componentType === 'vaporLiquidSeparator') {
                components.vaporLiquidSeparator.visible = true;
                components.pipeFromCalandriaToSeparator.visible = true; // Context
                components.pipeFromSeparatorToPump.visible = true; // Context
                components.vaporOutlet.visible = true; // Context
                components.concentrateOutlet.visible = true; // Context
                components.fluidFlowCirculation.visible = true;
                components.fluidFlowVapor.visible = true;
                components.fluidFlowConcentrate.visible = true;
            } else if (componentType === 'calandria') {
                components.calandriaShell.visible = true;
                components.calandriaTubes.visible = true;
                components.pipeFromPumpToCalandria.visible = true; // Context
                components.pipeFromCalandriaToSeparator.visible = true; // Context
                components.heatingMediumIO.visible = true; // Context
                components.fluidFlowCirculation.visible = true;
                components.fluidFlowHeatingMedium.visible = true;
            } else if (componentType === 'circulationPump') {
                components.circulationPump.visible = true;
                components.pipeFromSeparatorToPump.visible = true; // Context
                components.pipeFromPumpToCalandria.visible = true; // Context
                components.liquidInlet.visible = true; // Context
                components.fluidFlowCirculation.visible = true;
                components.fluidFlowFeed.visible = true;
            } else if (componentType === 'liquidInlet') {
                components.liquidInlet.visible = true;
                components.circulationPump.visible = true; // Context
                components.fluidFlowFeed.visible = true;
                components.fluidFlowCirculation.visible = true;
            } else if (componentType === 'vaporOutlet') {
                components.vaporOutlet.visible = true;
                components.vaporLiquidSeparator.visible = true; // Context
                components.fluidFlowVapor.visible = true;
            } else if (componentType === 'concentrateOutlet') {
                components.concentrateOutlet.visible = true;
                components.vaporLiquidSeparator.visible = true; // Context
                components.fluidFlowConcentrate.visible = true;
            } else if (componentType === 'heatingMediumIO') {
                components.heatingMediumIO.visible = true;
                components.calandriaShell.visible = true; // Context
                components.fluidFlowHeatingMedium.visible = true;
            } else if (componentType === 'full') {
                Object.values(components).forEach(comp => {
                    if (comp && comp !== components.fullAssembly) comp.visible = true;
                });
                // Show all fluid animations in full view by default
                components.fluidFlowFeed.visible = true;
                components.fluidFlowCirculation.visible = true;
                components.fluidFlowVapor.visible = true;
                components.fluidFlowConcentrate.visible = true;
                components.fluidFlowHeatingMedium.visible = true;
            }
            
            // Update info panel if showing single component
            if (componentType !== 'full' && componentInfo[componentType]) {
                document.getElementById('component-title').textContent = componentInfo[componentType].title;
                document.getElementById('component-description').textContent = componentInfo[componentType].description;
                document.getElementById('info-panel').style.display = 'block';
            } else {
                document.getElementById('info-panel').style.display = 'none';
            }
            
            // Focus camera on the shown component(s)
            let targetObject;
            if (componentType === 'vaporLiquidSeparator') targetObject = components.vaporLiquidSeparator;
            else if (componentType === 'calandria') targetObject = components.calandriaShell;
            else if (componentType === 'circulationPump') targetObject = components.circulationPump;
            else if (componentType === 'liquidInlet') targetObject = components.liquidInlet;
            else if (componentType === 'vaporOutlet') targetObject = components.vaporOutlet;
            else if (componentType === 'concentrateOutlet') targetObject = components.concentrateOutlet;
            else if (componentType === 'heatingMediumIO') targetObject = components.heatingMediumIO;
            else targetObject = components.fullAssembly;
            
            animateCameraToComponent(targetObject);
        }

        // Camera animation to focus on object
        function animateCameraToComponent(object) {
            if (isAnimating) return;
            
            isAnimating = true;
            controls.enabled = false; // Disable orbit controls during animation
            
            const boundingBox = new THREE.Box3().setFromObject(object);
            const size = boundingBox.getSize(new THREE.Vector3());
            const center = boundingBox.getCenter(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 2.5; // Adjusted multiplier for desired zoom level
            
            // Calculate target position for camera
            const currentCameraPosition = camera.position.clone();
            const currentLookAt = controls.target.clone();

            // Determine a direction from the object's center to place the camera
            let direction = new THREE.Vector3().subVectors(currentCameraPosition, center).normalize();
            if (direction.length() === 0) direction.set(0.5, 0.5, 1).normalize(); // Fallback if camera is at center

            targetPosition = new THREE.Vector3().copy(center).add(direction.multiplyScalar(distance));
            targetLookAt = center.clone();
            
            animateCamera();
        }

        function animateCamera() {
            if (!targetPosition || !targetLookAt) return;
            
            const moveSpeed = 0.05; // Slower for smoother transition
            const lookSpeed = 0.05;
            
            camera.position.lerp(targetPosition, moveSpeed);
            controls.target.lerp(targetLookAt, lookSpeed);
            
            const positionDiff = camera.position.distanceTo(targetPosition);
            const lookDiff = controls.target.distanceTo(targetLookAt);
            
            if (positionDiff < 0.1 && lookDiff < 0.1) { // Threshold for animation end
                camera.position.copy(targetPosition);
                controls.target.copy(targetLookAt);
                isAnimating = false;
                controls.enabled = true; // Re-enable orbit controls
                return;
            }
            
            animationId = requestAnimationFrame(animateCamera);
        }

        // Toggle section view
        function toggleSectionView() {
            isSectionView = !isSectionView;
            renderer.localClippingEnabled = isSectionView;
            sectionHelper.visible = isSectionView;
            
            // Toggle fluid visibility based on section view
            components.fluidFlowFeed.visible = isSectionView;
            components.fluidFlowCirculation.visible = isSectionView;
            components.fluidFlowVapor.visible = isSectionView;
            components.fluidFlowConcentrate.visible = isSectionView;
            components.fluidFlowHeatingMedium.visible = isSectionView;


            scene.traverse(child => {
                if (child.isMesh) {
                    // Apply clipping planes only to components that are part of the main assembly
                    const componentType = child.userData.type;
                    if (componentType === 'vaporLiquidSeparator' || componentType === 'calandria' || 
                        componentType === 'circulationPump' || componentType === 'circulationPipe') {
                         child.material.clippingPlanes = isSectionView ? [sectionPlane] : null;
                    } else {
                        child.material.clippingPlanes = null;
                    }
                    child.material.needsUpdate = true;
                }
            });
            
            document.getElementById('section-view').textContent = 
                isSectionView ? 'Full View' : 'Section View';
        }

        // Handle mouse clicks
        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Calculate objects intersecting the ray
            const intersects = raycaster.intersectObjects(scene.children, true); // true for recursive check
            
            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                // Traverse up the hierarchy to find the main component group
                while (clickedObject && !clickedObject.userData.type && clickedObject.parent) {
                    clickedObject = clickedObject.parent;
                }
                
                if (clickedObject && clickedObject.userData.type) {
                    const componentType = clickedObject.userData.type;
                    showOnly(componentType);
                }
            }
        }

        // Set up UI controls
        document.getElementById('section-view').addEventListener('click', toggleSectionView);
        document.getElementById('reset-view').addEventListener('click', () => showOnly('full'));
        document.getElementById('view-vapor-liquid-separator').addEventListener('click', () => showOnly('vaporLiquidSeparator'));
        document.getElementById('view-calandria').addEventListener('click', () => showOnly('calandria'));
        document.getElementById('view-circulation-pump').addEventListener('click', () => showOnly('circulationPump'));
        document.getElementById('view-liquid-inlet').addEventListener('click', () => showOnly('liquidInlet'));
        document.getElementById('view-vapor-outlet').addEventListener('click', () => showOnly('vaporOutlet'));
        document.getElementById('view-concentrate-outlet').addEventListener('click', () => showOnly('concentrateOutlet'));
        document.getElementById('view-heating-medium-io').addEventListener('click', () => showOnly('heatingMediumIO'));

        window.addEventListener('click', onMouseClick, false);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate); // Request next frame
            controls.update(); // Update orbit controls

            // Animate feed particles
            if (components.fluidFlowFeed.visible) {
                const feedParticles = components.fluidFlowFeed.children[0];
                const feedPositions = feedParticles.geometry.attributes.position.array;
                const feedPath = feedParticles.userData.paths[0]; 

                for (let i = 0; i < feedParticles.userData.progress.length; i++) {
                    feedParticles.userData.progress[i] = (feedParticles.userData.progress[i] + 0.005) % 1; // Adjust speed
                    const p = feedPath.getPointAt(feedParticles.userData.progress[i]);
                    feedPositions[i * 3] = p.x + (Math.random() - 0.5) * 0.2; // Slight drift
                    feedPositions[i * 3 + 1] = p.y + (Math.random() - 0.5) * 0.2;
                    feedPositions[i * 3 + 2] = p.z + (Math.random() - 0.5) * 0.2;
                }
                feedParticles.geometry.attributes.position.needsUpdate = true;
            }

            // Animate circulation particles
            if (components.fluidFlowCirculation.visible) {
                const circulationParticles = components.fluidFlowCirculation.children[0];
                const circulationPositions = circulationParticles.geometry.attributes.position.array;
                const circulationPath = circulationParticles.userData.paths[0]; 

                for (let i = 0; i < circulationParticles.userData.progress.length; i++) {
                    circulationParticles.userData.progress[i] = (circulationParticles.userData.progress[i] + 0.008) % 1; // Faster for circulation
                    const p = circulationPath.getPointAt(circulationParticles.userData.progress[i]);
                    circulationPositions[i * 3] = p.x + (Math.random() - 0.5) * 0.1; // Slight drift
                    circulationPositions[i * 3 + 1] = p.y + (Math.random() - 0.5) * 0.1;
                    circulationPositions[i * 3 + 2] = p.z + (Math.random() - 0.5) * 0.1;
                }
                circulationParticles.geometry.attributes.position.needsUpdate = true;
            }

            // Animate vapor particles
            if (components.fluidFlowVapor.visible) {
                const vaporParticles = components.fluidFlowVapor.children[0];
                const vaporPositions = vaporParticles.geometry.attributes.position.array;
                const vaporPath = vaporParticles.userData.paths[0]; 

                for (let i = 0; i < vaporParticles.userData.progress.length; i++) {
                    vaporParticles.userData.progress[i] = (vaporParticles.userData.progress[i] + 0.004) % 1; // Adjust speed
                    const p = vaporPath.getPointAt(vaporParticles.userData.progress[i]);
                    vaporPositions[i * 3] = p.x + (Math.random() - 0.5) * 0.3; // More drift for vapor
                    vaporPositions[i * 3 + 1] = p.y + (Math.random() - 0.5) * 0.3;
                    vaporPositions[i * 3 + 2] = p.z + (Math.random() - 0.5) * 0.3;
                }
                vaporParticles.geometry.attributes.position.needsUpdate = true;
            }

            // Animate concentrate particles
            if (components.fluidFlowConcentrate.visible) {
                const concentrateParticles = components.fluidFlowConcentrate.children[0];
                const concentratePositions = concentrateParticles.geometry.attributes.position.array;
                const concentratePath = concentrateParticles.userData.paths[0]; 

                for (let i = 0; i < concentrateParticles.userData.progress.length; i++) {
                    concentrateParticles.userData.progress[i] = (concentrateParticles.userData.progress[i] + 0.003) % 1; // Slower for concentrate
                    const p = concentratePath.getPointAt(concentrateParticles.userData.progress[i]);
                    concentratePositions[i * 3] = p.x;
                    concentratePositions[i * 3 + 1] = p.y;
                    concentratePositions[i * 3 + 2] = p.z;
                }
                concentrateParticles.geometry.attributes.position.needsUpdate = true;
            }

            // Animate heating medium particles
            if (components.fluidFlowHeatingMedium.visible) {
                const heatingMediumParticles = components.fluidFlowHeatingMedium.children[0];
                const heatingMediumPositions = heatingMediumParticles.geometry.attributes.position.array;
                const heatingMediumPath = heatingMediumParticles.userData.paths[0]; 

                for (let i = 0; i < heatingMediumParticles.userData.progress.length; i++) {
                    heatingMediumParticles.userData.progress[i] = (heatingMediumParticles.userData.progress[i] + 0.006) % 1; // Adjust speed
                    const p = heatingMediumPath.getPointAt(heatingMediumParticles.userData.progress[i]);
                    heatingMediumPositions[i * 3] = p.x + (Math.random() - 0.5) * 0.2;
                    heatingMediumPositions[i * 3 + 1] = p.y + (Math.random() - 0.5) * 0.2;
                    heatingMediumPositions[i * 3 + 2] = p.z + (Math.random() - 0.5) * 0.2;
                }
                heatingMediumParticles.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera); // Render the scene
        }
        
        // Start the animation on window load.
        window.onload = function () {
            animate(); 
        }
    </script>
</body>
</html>
