<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indirect Evaporative Cooler</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            color: #ffffff;
        }
        canvas {
            display: block;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 15px;
            border-radius: 8px;
            max-width: 600px;
            text-align: center;
            transition: all 0.5s ease;
            z-index: 100;
            border: 1px solid #00BCD4; /* Cyan border for cooler theme */
            box-shadow: 0 4px 15px rgba(0, 188, 212, 0.2); /* Cyan shadow */
        }
        .info-panel h3 {
            margin-top: 0;
            color: #80DEEA; /* Lighter cyan for info panel title */
            font-size: 22px;
        }
        .info-panel p {
            margin-bottom: 0;
            font-size: 16px;
            line-height: 1.5;
        }
        #title {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: #ffffff;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            z-index: 100;
            border-radius: 8px;
        }
        #controls {
            position: absolute;
            top: 70px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            background-color: rgba(0, 0, 0, 0.9);
            color: #ffffff;
            border: 2px solid #00BCD4; /* Thicker cyan border */
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            min-width: 180px;
            text-align: left;
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 188, 212, 0.3);
        }
        button:hover {
            background-color: rgba(0, 188, 212, 0.3); /* Lighter cyan on hover */
            border-color: #80DEEA; /* Lighter border on hover */
            box-shadow: 0 6px 15px rgba(0, 188, 212, 0.4);
        }
        .component-button {
            display: flex;
            align-items: center;
        }
        .component-button .color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            display: inline-block;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div id="title">Indirect Evaporative Cooler - Click on any component</div>
    <div id="controls">
        <button id="reset-view">Show Full Assembly</button>
        <button id="section-view">Section View</button>
        <div style="margin-top: 10px; color: #ffffff; font-size: 14px;">Component Quick View:</div>
        <button id="view-casing"><span class="color-indicator" style="background-color: #607D8B;"></span>View Casing</button>
        <button id="view-heat-exchanger"><span class="color-indicator" style="background-color: #FFC107;"></span>View Heat Exchanger</button>
        <button id="view-water-reservoir"><span class="color-indicator" style="background-color: #2196F3;"></span>View Water Reservoir</button>
        <button id="view-pump"><span class="color-indicator" style="background-color: #FF7043;"></span>View Pump</button>
        <button id="view-water-distribution"><span class="color-indicator" style="background-color: #03A9F4;"></span>View Water Distribution</button>
        <button id="view-primary-fan"><span class="color-indicator" style="background-color: #9E9E9E;"></span>View Primary Fan</button>
        <button id="view-secondary-fan"><span class="color-indicator" style="background-color: #BDBDBD;"></span>View Secondary Fan</button>
        <button id="view-primary-air-inlet"><span class="color-indicator" style="background-color: #FF5722;"></span>View Primary Air Inlet</button>
        <button id="view-cooled-air-outlet"><span class="color-indicator" style="background-color: #4CAF50;"></span>View Cooled Air Outlet</button>
        <button id="view-secondary-air-inlet"><span class="color-indicator" style="background-color: #FFEB3B;"></span>View Secondary Air Inlet</button>
        <button id="view-humid-air-exhaust"><span class="color-indicator" style="background-color: #E91E63;"></span>View Humid Air Exhaust</button>
    </div>
    <div id="info-panel" class="info-panel" style="display: none;">
        <h3 id="component-title">Component</h3>
        <p id="component-description">Description will appear here</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/curves/CatmullRomCurve3.js"></script>
    <script>
        // Main Three.js variables
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Black background

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(35, 30, 45); // Initial camera position
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        document.body.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth camera movement
        controls.dampingFactor = 0.05;
        controls.target.set(0, 15, 0); // Point camera towards the center of the cooler
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Soft ambient light
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Main light source
        directionalLight.position.set(25, 60, 35); // Positioned above and to the side
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 180;
        directionalLight.shadow.camera.left = -70;
        directionalLight.shadow.camera.right = 70;
        directionalLight.shadow.camera.top = 70;
        directionalLight.shadow.camera.bottom = -70;
        scene.add(directionalLight);
        
        const backLight = new THREE.DirectionalLight(0xffffff, 0.3); // Secondary light
        backLight.position.set(-25, -60, -35);
        scene.add(backLight);
        
        // Interaction tools
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Animation variables
        let animationId = null;
        let targetPosition = null;
        let targetLookAt = null;
        let isAnimating = false;
        
        // Section view
        let isSectionView = false;
        const sectionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); 
        const sectionHelper = new THREE.PlaneHelper(sectionPlane, 20, 0xff0000);
        sectionHelper.visible = false;
        scene.add(sectionHelper);
        renderer.localClippingEnabled = false;

        // Component storage
        const components = {
            casing: null,
            heatExchanger: null,
            waterReservoir: null,
            pump: null,
            waterDistribution: null,
            primaryFan: null,
            secondaryFan: null,
            primaryAirInlet: null,
            cooledAirOutlet: null,
            secondaryAirInlet: null,
            humidAirExhaust: null,
            waterParticles: null,
            primaryAirParticles: null,
            secondaryAirParticles: null,
            fullAssembly: null
        };
        
        // Component information
        const componentInfo = {
            'casing': {
                title: 'Cooler Casing',
                description: 'The robust outer shell of the indirect evaporative cooler, housing all internal components and providing structural integrity.',
                color: 0x607D8B, // Blue Grey 500
            },
            'heatExchanger': {
                title: 'Heat Exchanger Core',
                description: 'The central component where primary (supply) air passes through dry channels and secondary (exhaust) air passes through wet channels, allowing heat exchange without mixing.',
                color: 0xFFC107, // Amber 500
            },
            'waterReservoir': {
                title: 'Water Reservoir',
                description: 'The basin at the base of the cooler that stores the water used for evaporating in the secondary air channels.',
                color: 0x2196F3, // Blue 500
            },
            'pump': {
                title: 'Water Pump',
                description: 'Circulates water from the reservoir to the water distribution system, wetting the secondary air channels of the heat exchanger.',
                color: 0xFF7043, // Deep Orange 300
            },
            'waterDistribution': {
                title: 'Water Distribution System',
                description: 'A network of pipes and nozzles that evenly disperses water over the wet channels of the heat exchanger core.',
                color: 0x03A9F4, // Light Blue 500
            },
            'primaryFan': {
                title: 'Primary Air Fan',
                description: 'Draws warm ambient air into the dry channels of the heat exchanger and pushes the cooled, dry air into the conditioned space.',
                color: 0x9E9E9E, // Grey 500
            },
            'secondaryFan': {
                title: 'Secondary Air Fan',
                description: 'Draws air through the wet channels of the heat exchanger, where it is humidified and cooled, and then exhausts it to the outside.',
                color: 0xBDBDBD, // Grey 400
            },
            'primaryAirInlet': {
                title: 'Primary Air Inlet',
                description: 'The opening where the warm, dry ambient air first enters the cooler to be conditioned.',
                color: 0xFF5722, // Deep Orange 500
            },
            'cooledAirOutlet': {
                title: 'Cooled Air Outlet',
                description: 'The opening from which the cooled, dry supply air is delivered to the indoor environment.',
                color: 0x4CAF50, // Green 500
            },
            'secondaryAirInlet': {
                title: 'Secondary Air Inlet',
                description: 'The opening where a portion of the ambient air or recirculated room air enters the wet channels for evaporative cooling.',
                color: 0xFFEB3B, // Yellow 500
            },
            'humidAirExhaust': {
                title: 'Humid Air Exhaust',
                description: 'The outlet where the humidified and cooled secondary air is expelled from the system to the outside.',
                color: 0xE91E63, // Pink 500
            }
        };

        // Global constants for cooler dimensions
        const coolerWidth = 25;
        const coolerHeight = 30;
        const coolerDepth = 20;

        const casingThickness = 0.8;
        const reservoirHeight = 4;
        const exchangerWidth = coolerWidth * 0.8;
        const exchangerHeight = coolerHeight * 0.5;
        const exchangerDepth = coolerDepth * 0.8;
        const channelThickness = 0.2; // Thickness of each air channel wall

        const fanRadius = 5;
        const fanThickness = 2;
        const pumpSize = 1.5;
        const pipeRadius = 0.3;

        // Global constants for fluid particles
        const particleSizeWater = 0.3;
        const particleSizePrimaryAir = 0.4;
        const particleSizeSecondaryAir = 0.4;


        // Create all components of the indirect evaporative cooler
        function createComponents() {
            const coolerGroup = new THREE.Group();
            coolerGroup.position.y = coolerHeight / 2; // Position base at Y=0

            // Casing (transparent)
            const casingMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.casing.color,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 0.5,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            components.casing = new THREE.Mesh(
                new THREE.BoxGeometry(coolerWidth, coolerHeight, coolerDepth),
                casingMaterial
            );
            components.casing.position.y = 0;
            components.casing.userData = { type: 'casing' };
            coolerGroup.add(components.casing);

            // Water Reservoir
            const reservoirMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.waterReservoir.color,
                transparent: true,
                opacity: 0.7,
                roughness: 0.3,
                metalness: 0.1
            });
            components.waterReservoir = new THREE.Mesh(
                new THREE.BoxGeometry(coolerWidth * 0.9, reservoirHeight, coolerDepth * 0.9),
                reservoirMaterial
            );
            components.waterReservoir.position.y = -coolerHeight / 2 + reservoirHeight / 2;
            components.waterReservoir.userData = { type: 'waterReservoir' };
            coolerGroup.add(components.waterReservoir);

            // Pump
            const pumpMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.pump.color,
                metalness: 0.8,
                roughness: 0.4
            });
            const pumpBase = new THREE.Mesh(new THREE.CylinderGeometry(pumpSize / 2, pumpSize / 2, pumpSize, 16), pumpMaterial);
            pumpBase.position.set(coolerWidth / 2 - pumpSize, -coolerHeight / 2 + reservoirHeight + pumpSize / 2, coolerDepth / 2 - pumpSize);
            
            const pumpTop = new THREE.Mesh(new THREE.SphereGeometry(pumpSize / 2 * 0.8, 16, 16), pumpMaterial);
            pumpTop.position.set(pumpBase.position.x, pumpBase.position.y + pumpSize / 2, pumpBase.position.z);
            
            components.pump = new THREE.Group();
            components.pump.add(pumpBase);
            components.pump.add(pumpTop);
            components.pump.userData = { type: 'pump' };
            coolerGroup.add(components.pump);

            // Heat Exchanger Core (simplified as a block with internal channels)
            components.heatExchanger = new THREE.Group();
            const exchangerPlateMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.heatExchanger.color,
                transparent: true,
                opacity: 0.8,
                roughness: 0.5,
                metalness: 0.2,
                side: THREE.DoubleSide
            });

            const numPlates = 15; // Number of plates to simulate channels
            const totalPlateThickness = exchangerDepth; // Total depth for plates
            const singlePlateThickness = totalPlateThickness / numPlates;

            for (let i = 0; i < numPlates; i++) {
                const plate = new THREE.Mesh(
                    new THREE.BoxGeometry(exchangerWidth, exchangerHeight, singlePlateThickness * 0.8), // Slightly thinner for spacing
                    exchangerPlateMaterial
                );
                plate.position.z = -totalPlateThickness / 2 + (i + 0.5) * singlePlateThickness;
                plate.userData = { type: 'heatExchanger' };
                components.heatExchanger.add(plate);
            }
            components.heatExchanger.position.y = components.waterReservoir.position.y + reservoirHeight / 2 + exchangerHeight / 2 + 1;
            components.heatExchanger.userData = { type: 'heatExchanger' }; // Set userData on the group
            coolerGroup.add(components.heatExchanger);

            // Water Distribution System (above heat exchanger)
            components.waterDistribution = new THREE.Group();
            const distMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.waterDistribution.color,
                transparent: true,
                opacity: 0.7,
                roughness: 0.4
            });
            const distTray = new THREE.Mesh(
                new THREE.BoxGeometry(exchangerWidth * 0.9, 0.5, exchangerDepth * 0.9),
                distMaterial
            );
            distTray.position.y = components.heatExchanger.position.y + exchangerHeight / 2 + 0.25;
            distTray.userData = { type: 'waterDistribution' };
            components.waterDistribution.add(distTray);

            // More detailed nozzles
            const numNozzles = 10;
            for (let i = 0; i < numNozzles; i++) {
                const nozzle = new THREE.Mesh(
                    new THREE.CylinderGeometry(pipeRadius * 0.8, pipeRadius * 0.5, 0.8, 8), // Tapered nozzle
                    distMaterial
                );
                nozzle.position.set(
                    (Math.random() - 0.5) * (exchangerWidth * 0.8),
                    distTray.position.y + 0.25,
                    (Math.random() - 0.5) * (exchangerDepth * 0.8)
                );
                nozzle.userData = { type: 'waterDistribution' };
                components.waterDistribution.add(nozzle);
            }
            coolerGroup.add(components.waterDistribution);

            // Primary Air Fan (top)
            components.primaryFan = new THREE.Group();
            const primaryFanHousingMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.primaryFan.color,
                metalness: 0.6,
                roughness: 0.5
            });
            const fanBladeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x546E7A,
                metalness: 0.9,
                roughness: 0.3
            });

            const primaryFanHousing = new THREE.Mesh(
                new THREE.CylinderGeometry(fanRadius + 0.5, fanRadius + 0.5, fanThickness + 0.5, 32),
                primaryFanHousingMaterial
            );
            primaryFanHousing.position.y = coolerHeight / 2 - fanThickness / 2;
            primaryFanHousing.userData = { type: 'primaryFan' };
            components.primaryFan.add(primaryFanHousing);

            // More detailed fan blades
            for (let i = 0; i < 5; i++) { // More blades
                const bladeShape = new THREE.Shape();
                bladeShape.moveTo(0, 0);
                bladeShape.lineTo(fanRadius * 0.2, fanRadius * 0.8);
                bladeShape.lineTo(fanRadius * 0.1, fanRadius * 0.9);
                bladeShape.lineTo(-fanRadius * 0.1, fanRadius * 0.9);
                bladeShape.lineTo(-fanRadius * 0.2, fanRadius * 0.8);
                bladeShape.lineTo(0, 0);
                const bladeGeometry = new THREE.ExtrudeGeometry(bladeShape, {
                    steps: 1,
                    depth: 0.2,
                    bevelEnabled: false
                });
                const blade = new THREE.Mesh(bladeGeometry, fanBladeMaterial);
                blade.position.y = primaryFanHousing.position.y;
                blade.rotation.z = (Math.PI * 2 / 5) * i; // Distribute blades
                blade.userData = { type: 'primaryFan' };
                components.primaryFan.add(blade);
            }
            coolerGroup.add(components.primaryFan);

            // Secondary Air Fan (side/back)
            components.secondaryFan = new THREE.Group();
            const secondaryFanHousingMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.secondaryFan.color,
                metalness: 0.6,
                roughness: 0.5
            });
            const secondaryFanHousing = new THREE.Mesh(
                new THREE.CylinderGeometry(fanRadius * 0.7, fanRadius * 0.7, fanThickness, 32),
                secondaryFanHousingMaterial
            );
            secondaryFanHousing.rotation.x = Math.PI / 2; // Rotate to be on the side
            secondaryFanHousing.position.set(-coolerWidth / 2 + fanThickness / 2, components.heatExchanger.position.y, -coolerDepth / 2 + fanRadius * 0.7);
            secondaryFanHousing.userData = { type: 'secondaryFan' };
            components.secondaryFan.add(secondaryFanHousing);

            for (let i = 0; i < 4; i++) { // More blades
                const bladeShape = new THREE.Shape();
                bladeShape.moveTo(0, 0);
                bladeShape.lineTo(fanRadius * 0.15, fanRadius * 0.6);
                bladeShape.lineTo(fanRadius * 0.08, fanRadius * 0.7);
                bladeShape.lineTo(-fanRadius * 0.08, fanRadius * 0.7);
                bladeShape.lineTo(-fanRadius * 0.15, fanRadius * 0.6);
                bladeShape.lineTo(0, 0);
                const bladeGeometry = new THREE.ExtrudeGeometry(bladeShape, {
                    steps: 1,
                    depth: 0.15,
                    bevelEnabled: false
                });
                const blade = new THREE.Mesh(bladeGeometry, fanBladeMaterial);
                blade.position.y = secondaryFanHousing.position.y;
                blade.rotation.z = (Math.PI * 2 / 4) * i;
                blade.userData = { type: 'secondaryFan' };
                components.secondaryFan.add(blade);
            }
            coolerGroup.add(components.secondaryFan);


            // Primary Air Inlet (with a grille)
            const primaryAirInletMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.primaryAirInlet.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            components.primaryAirInlet = new THREE.Group();
            const inletBox = new THREE.Mesh(
                new THREE.BoxGeometry(coolerWidth * 0.8, 0.1, coolerDepth * 0.2),
                primaryAirInletMaterial
            );
            inletBox.position.set(0, components.primaryFan.position.y - fanThickness / 2 - 0.05, coolerDepth / 2 - coolerDepth * 0.1);
            inletBox.userData = { type: 'primaryAirInlet' };
            components.primaryAirInlet.add(inletBox);

            // Simple grille
            const grilleMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const grilleBarWidth = 0.5;
            const numBars = Math.floor((coolerWidth * 0.8) / (grilleBarWidth * 2));
            for (let i = 0; i < numBars; i++) {
                const bar = new THREE.Mesh(new THREE.BoxGeometry(grilleBarWidth, coolerDepth * 0.2 * 0.8, 0.1), grilleMaterial);
                bar.position.set(
                    - (coolerWidth * 0.8) / 2 + (i + 0.5) * (grilleBarWidth * 2),
                    inletBox.position.y,
                    inletBox.position.z
                );
                bar.rotation.x = Math.PI / 2;
                components.primaryAirInlet.add(bar);
            }
            components.primaryAirInlet.userData = { type: 'primaryAirInlet' }; // Set on group
            coolerGroup.add(components.primaryAirInlet);

            // Cooled Air Outlet (with a grille)
            const cooledAirOutletMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.cooledAirOutlet.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            components.cooledAirOutlet = new THREE.Group();
            const outletBox = new THREE.Mesh(
                new THREE.BoxGeometry(fanRadius * 2 + 1, 0.1, fanRadius * 2 + 1),
                cooledAirOutletMaterial
            );
            outletBox.position.set(components.primaryFan.position.x, coolerHeight / 2 - 0.05, components.primaryFan.position.z);
            outletBox.userData = { type: 'cooledAirOutlet' };
            components.cooledAirOutlet.add(outletBox);
            
            const outletGrilleNumBars = Math.floor((fanRadius * 2 + 1) / (grilleBarWidth * 2));
            for (let i = 0; i < outletGrilleNumBars; i++) {
                const bar = new THREE.Mesh(new THREE.BoxGeometry(grilleBarWidth, fanRadius * 2 + 1 * 0.8, 0.1), grilleMaterial);
                bar.position.set(
                    - (fanRadius * 2 + 1) / 2 + (i + 0.5) * (grilleBarWidth * 2),
                    outletBox.position.y,
                    outletBox.position.z
                );
                bar.rotation.x = Math.PI / 2;
                components.cooledAirOutlet.add(bar);
            }
            components.cooledAirOutlet.userData = { type: 'cooledAirOutlet' }; // Set on group
            coolerGroup.add(components.cooledAirOutlet);


            // Secondary Air Inlet (with a grille)
            const secondaryAirInletMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.secondaryAirInlet.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            components.secondaryAirInlet = new THREE.Group();
            const secInletBox = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, coolerHeight * 0.3, coolerDepth * 0.5),
                secondaryAirInletMaterial
            );
            secInletBox.position.set(-coolerWidth / 2 + 0.05, components.heatExchanger.position.y, coolerDepth / 2 - coolerDepth * 0.25);
            secInletBox.userData = { type: 'secondaryAirInlet' };
            components.secondaryAirInlet.add(secInletBox);

            const secInletGrilleNumBars = Math.floor((coolerHeight * 0.3) / (grilleBarWidth * 2));
            for (let i = 0; i < secInletGrilleNumBars; i++) {
                const bar = new THREE.Mesh(new THREE.BoxGeometry(0.1, grilleBarWidth, coolerDepth * 0.5 * 0.8), grilleMaterial);
                bar.position.set(
                    secInletBox.position.x,
                    - (coolerHeight * 0.3) / 2 + (i + 0.5) * (grilleBarWidth * 2),
                    secInletBox.position.z
                );
                bar.rotation.y = Math.PI / 2;
                components.secondaryAirInlet.add(bar);
            }
            components.secondaryAirInlet.userData = { type: 'secondaryAirInlet' }; // Set on group
            coolerGroup.add(components.secondaryAirInlet);


            // Humid Air Exhaust (with a grille)
            const humidAirExhaustMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.humidAirExhaust.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            components.humidAirExhaust = new THREE.Group();
            const exhaustBox = new THREE.Mesh(
                new THREE.BoxGeometry(coolerWidth * 0.2, coolerHeight * 0.1, 0.1),
                humidAirExhaustMaterial
            );
            exhaustBox.position.set(coolerWidth / 2 - coolerWidth * 0.1, components.heatExchanger.position.y + exchangerHeight / 2 + 1, -coolerDepth / 2 + 0.05);
            exhaustBox.userData = { type: 'humidAirExhaust' };
            components.humidAirExhaust.add(exhaustBox);

            const exhaustGrilleNumBars = Math.floor((coolerWidth * 0.2) / (grilleBarWidth * 2));
            for (let i = 0; i < exhaustGrilleNumBars; i++) {
                const bar = new THREE.Mesh(new THREE.BoxGeometry(grilleBarWidth, coolerHeight * 0.1 * 0.8, 0.1), grilleMaterial);
                bar.position.set(
                    - (coolerWidth * 0.2) / 2 + (i + 0.5) * (grilleBarWidth * 2),
                    exhaustBox.position.y,
                    exhaustBox.position.z
                );
                bar.rotation.x = Math.PI / 2;
                components.humidAirExhaust.add(bar);
            }
            components.humidAirExhaust.userData = { type: 'humidAirExhaust' }; // Set on group
            coolerGroup.add(components.humidAirExhaust);


            // --- Fluid Flow Animations ---
            function createFluidParticles(color, numParticles, size, blending = THREE.AdditiveBlending, opacity = 0.7) {
                const positions = new Float32Array(numParticles * 3);
                const particles = new THREE.BufferAttribute(positions, 3);
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', particles);

                const material = new THREE.PointsMaterial({
                    color: color,
                    size: size,
                    blending: blending,
                    transparent: true,
                    opacity: opacity,
                    sizeAttenuation: true
                });

                const points = new THREE.Points(geometry, material);
                points.userData.progress = new Array(numParticles).fill(0).map(() => Math.random());
                return points;
            }

            // Water Particles
            components.waterParticles = createFluidParticles(0x00BFFF, 200, particleSizeWater); // Deep Sky Blue
            components.waterParticles.userData.paths = [];

            for (let i = 0; i < 5; i++) {
                const startPoint = new THREE.Vector3(
                    (Math.random() - 0.5) * (coolerWidth * 0.8),
                    components.waterReservoir.position.y + reservoirHeight / 2 - 0.5,
                    (Math.random() - 0.5) * (coolerDepth * 0.8)
                );
                const midPointPump = components.pump.position.clone().add(new THREE.Vector3(0, pumpSize / 2 + 1, 0));
                const midPointDist = components.waterDistribution.position.clone().add(new THREE.Vector3(
                    (Math.random() - 0.5) * (exchangerWidth * 0.5),
                    0.5,
                    (Math.random() - 0.5) * (exchangerDepth * 0.5)
                ));
                const endPointExchanger = components.heatExchanger.position.clone().add(new THREE.Vector3(
                    (Math.random() - 0.5) * (exchangerWidth * 0.5),
                    -exchangerHeight / 2 - 0.5,
                    (Math.random() - 0.5) * (exchangerDepth * 0.5)
                ));

                const pathPoints = [
                    startPoint,
                    midPointPump,
                    midPointDist,
                    endPointExchanger,
                    startPoint.clone().add(new THREE.Vector3(0, -1, 0))
                ];
                components.waterParticles.userData.paths.push(new THREE.CatmullRomCurve3(pathPoints));
            }
            coolerGroup.add(components.waterParticles);

            // Primary Air Particles (dry, cooled air)
            components.primaryAirParticles = createFluidParticles(0xF0F8FF, 350, particleSizePrimaryAir); // Alice Blue
            components.primaryAirParticles.userData.paths = [];

            for (let i = 0; i < 10; i++) {
                const inletX = components.primaryAirInlet.position.x + (Math.random() * 2 - 1) * (coolerWidth * 0.3);
                const inletY = components.primaryAirInlet.position.y;
                const inletZ = components.primaryAirInlet.position.z + (Math.random() * 2 - 1) * (coolerDepth * 0.1);

                const outletX = components.cooledAirOutlet.position.x + (Math.random() * 2 - 1) * (fanRadius * 0.8);
                const outletY = components.cooledAirOutlet.position.y;
                const outletZ = components.cooledAirOutlet.position.z + (Math.random() * 2 - 1) * (fanRadius * 0.8);

                const pathPoints = [
                    new THREE.Vector3(inletX, inletY, inletZ), // From primary inlet
                    new THREE.Vector3(inletX * 0.5, components.heatExchanger.position.y + exchangerHeight / 2 - 0.5, inletZ * 0.5), // Into heat exchanger (dry path)
                    new THREE.Vector3(outletX, outletY, outletZ) // Exiting cooled air outlet
                ];
                components.primaryAirParticles.userData.paths.push(new THREE.CatmullRomCurve3(pathPoints));
            }
            coolerGroup.add(components.primaryAirParticles);

            // Secondary Air Particles (humid, exhaust air)
            components.secondaryAirParticles = createFluidParticles(0xADD8E6, 300, particleSizeSecondaryAir); // Light Blue
            components.secondaryAirParticles.userData.paths = [];

            for (let i = 0; i < 9; i++) {
                const inletX = components.secondaryAirInlet.position.x + 0.1 + (Math.random() * 2 - 1) * (coolerWidth * 0.1);
                const inletY = components.secondaryAirInlet.position.y + (Math.random() * 2 - 1) * (coolerHeight * 0.1);
                const inletZ = components.secondaryAirInlet.position.z + (Math.random() * 2 - 1) * (coolerDepth * 0.2);

                const exhaustX = components.humidAirExhaust.position.x + (Math.random() * 2 - 1) * (coolerWidth * 0.05);
                const exhaustY = components.humidAirExhaust.position.y + (Math.random() * 2 - 1) * (coolerHeight * 0.05);
                const exhaustZ = components.humidAirExhaust.position.z + 0.1 + (Math.random() * 2 - 1) * (coolerDepth * 0.05);

                const pathPoints = [
                    new THREE.Vector3(inletX, inletY, inletZ), // From secondary inlet
                    new THREE.Vector3(inletX * 0.5, components.heatExchanger.position.y + exchangerHeight / 2 - 0.5, inletZ * 0.5), // Into heat exchanger (wet path)
                    new THREE.Vector3(exhaustX, exhaustY, exhaustZ) // Exiting humid air exhaust
                ];
                components.secondaryAirParticles.userData.paths.push(new THREE.CatmullRomCurve3(pathPoints));
            }
            coolerGroup.add(components.secondaryAirParticles);


            // Initially hide fluid/particle animations
            components.waterParticles.visible = false;
            components.primaryAirParticles.visible = false;
            components.secondaryAirParticles.visible = false;

            components.fullAssembly = coolerGroup;
            scene.add(components.fullAssembly);
        }

        // Show only specific component(s)
        function showOnly(componentType) {
            Object.values(components).forEach(comp => {
                if (comp && comp !== components.fullAssembly && 
                    !comp.userData.isFluidFlow && comp !== components.waterParticles &&
                    comp !== components.primaryAirParticles && comp !== components.secondaryAirParticles) { 
                    comp.visible = false;
                }
            });
            
            components.waterParticles.visible = false;
            components.primaryAirParticles.visible = false;
            components.secondaryAirParticles.visible = false;

            if (componentType === 'casing') {
                components.casing.visible = true;
            } else if (componentType === 'heatExchanger') {
                components.casing.visible = true;
                components.heatExchanger.visible = true;
                components.waterReservoir.visible = true; // Context
                components.waterDistribution.visible = true; // Context
                components.primaryAirInlet.visible = true; // Context
                components.cooledAirOutlet.visible = true; // Context
                components.secondaryAirInlet.visible = true; // Context
                components.humidAirExhaust.visible = true; // Context
                components.waterParticles.visible = true;
                components.primaryAirParticles.visible = true;
                components.secondaryAirParticles.visible = true;
            } else if (componentType === 'waterReservoir') {
                components.casing.visible = true;
                components.waterReservoir.visible = true;
                components.pump.visible = true; // Context
                components.waterParticles.visible = true;
            } else if (componentType === 'pump') {
                components.casing.visible = true;
                components.waterReservoir.visible = true; // Context
                components.pump.visible = true;
                components.waterDistribution.visible = true; // Context
                components.waterParticles.visible = true;
            } else if (componentType === 'waterDistribution') {
                components.casing.visible = true;
                components.waterDistribution.visible = true;
                components.heatExchanger.visible = true; // Context
                components.pump.visible = true; // Context
                components.waterParticles.visible = true;
            } else if (componentType === 'primaryFan') {
                components.casing.visible = true;
                components.primaryFan.visible = true;
                components.primaryAirInlet.visible = true; // Context
                components.cooledAirOutlet.visible = true; // Context
                components.primaryAirParticles.visible = true;
            } else if (componentType === 'secondaryFan') {
                components.casing.visible = true;
                components.secondaryFan.visible = true;
                components.secondaryAirInlet.visible = true; // Context
                components.humidAirExhaust.visible = true; // Context
                components.secondaryAirParticles.visible = true;
            } else if (componentType === 'primaryAirInlet') {
                components.casing.visible = true;
                components.primaryAirInlet.visible = true;
                components.heatExchanger.visible = true; // Context
                components.primaryAirParticles.visible = true;
            } else if (componentType === 'cooledAirOutlet') {
                components.casing.visible = true;
                components.cooledAirOutlet.visible = true;
                components.primaryFan.visible = true; // Context
                components.primaryAirParticles.visible = true;
            } else if (componentType === 'secondaryAirInlet') {
                components.casing.visible = true;
                components.secondaryAirInlet.visible = true;
                components.heatExchanger.visible = true; // Context
                components.secondaryAirParticles.visible = true;
            } else if (componentType === 'humidAirExhaust') {
                components.casing.visible = true;
                components.humidAirExhaust.visible = true;
                components.secondaryFan.visible = true; // Context
                components.secondaryAirParticles.visible = true;
            } else if (componentType === 'full') {
                Object.values(components).forEach(comp => {
                    if (comp && comp !== components.fullAssembly) comp.visible = true;
                });
                components.waterParticles.visible = true;
                components.primaryAirParticles.visible = true;
                components.secondaryAirParticles.visible = true;
            }
            
            if (componentType !== 'full' && componentInfo[componentType]) {
                document.getElementById('component-title').textContent = componentInfo[componentType].title;
                document.getElementById('component-description').textContent = componentInfo[componentType].description;
                document.getElementById('info-panel').style.display = 'block';
            } else {
                document.getElementById('info-panel').style.display = 'none';
            }
            
            let targetObject;
            if (componentType === 'casing') targetObject = components.casing;
            else if (componentType === 'heatExchanger') targetObject = components.heatExchanger;
            else if (componentType === 'waterReservoir') targetObject = components.waterReservoir;
            else if (componentType === 'pump') targetObject = components.pump;
            else if (componentType === 'waterDistribution') targetObject = components.waterDistribution;
            else if (componentType === 'primaryFan') targetObject = components.primaryFan;
            else if (componentType === 'secondaryFan') targetObject = components.secondaryFan;
            else if (componentType === 'primaryAirInlet') targetObject = components.primaryAirInlet;
            else if (componentType === 'cooledAirOutlet') targetObject = components.cooledAirOutlet;
            else if (componentType === 'secondaryAirInlet') targetObject = components.secondaryAirInlet;
            else if (componentType === 'humidAirExhaust') targetObject = components.humidAirExhaust;
            else targetObject = components.fullAssembly;
            
            animateCameraToComponent(targetObject);
        }

        function animateCameraToComponent(object) {
            if (isAnimating) return;
            
            isAnimating = true;
            controls.enabled = false;
            
            const boundingBox = new THREE.Box3().setFromObject(object);
            const size = boundingBox.getSize(new THREE.Vector3());
            const center = boundingBox.getCenter(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 2.5;
            
            const currentCameraPosition = camera.position.clone();
            const currentLookAt = controls.target.clone();

            let direction = new THREE.Vector3().subVectors(currentCameraPosition, center).normalize();
            if (direction.length() === 0) direction.set(0.5, 0.5, 1).normalize();

            targetPosition = new THREE.Vector3().copy(center).add(direction.multiplyScalar(distance));
            targetLookAt = center.clone();
            
            animateCamera();
        }

        function animateCamera() {
            if (!targetPosition || !targetLookAt) return;
            
            const moveSpeed = 0.05;
            const lookSpeed = 0.05;
            
            camera.position.lerp(targetPosition, moveSpeed);
            controls.target.lerp(targetLookAt, lookSpeed);
            
            const positionDiff = camera.position.distanceTo(targetPosition);
            const lookDiff = controls.target.distanceTo(targetLookAt);
            
            if (positionDiff < 0.1 && lookDiff < 0.1) {
                camera.position.copy(targetPosition);
                controls.target.copy(targetLookAt);
                isAnimating = false;
                controls.enabled = true;
                return;
            }
            
            animationId = requestAnimationFrame(animateCamera);
        }

        function toggleSectionView() {
            isSectionView = !isSectionView;
            renderer.localClippingEnabled = isSectionView;
            sectionHelper.visible = isSectionView;
            
            components.waterParticles.visible = isSectionView;
            components.primaryAirParticles.visible = isSectionView;
            components.secondaryAirParticles.visible = isSectionView;

            scene.traverse(child => {
                if (child.isMesh) {
                    const componentType = child.userData.type;
                    if (componentType === 'casing' || componentType === 'heatExchanger' || 
                        componentType === 'waterReservoir' || componentType === 'pump' || 
                        componentType === 'waterDistribution' || componentType === 'primaryFan' ||
                        componentType === 'secondaryFan' || componentType === 'primaryAirInlet' ||
                        componentType === 'cooledAirOutlet' || componentType === 'secondaryAirInlet' ||
                        componentType === 'humidAirExhaust') {
                         child.material.clippingPlanes = isSectionView ? [sectionPlane] : null;
                    } else {
                        child.material.clippingPlanes = null;
                    }
                    child.material.needsUpdate = true;
                }
            });
            
            document.getElementById('section-view').textContent = 
                isSectionView ? 'Full View' : 'Section View';
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                while (clickedObject && !clickedObject.userData.type && clickedObject.parent) {
                    clickedObject = clickedObject.parent;
                }
                
                if (clickedObject && clickedObject.userData.type) {
                    const componentType = clickedObject.userData.type;
                    showOnly(componentType);
                }
            }
        }

        document.getElementById('section-view').addEventListener('click', toggleSectionView);
        document.getElementById('reset-view').addEventListener('click', () => showOnly('full'));
        document.getElementById('view-casing').addEventListener('click', () => showOnly('casing'));
        document.getElementById('view-heat-exchanger').addEventListener('click', () => showOnly('heatExchanger'));
        document.getElementById('view-water-reservoir').addEventListener('click', () => showOnly('waterReservoir'));
        document.getElementById('view-pump').addEventListener('click', () => showOnly('pump'));
        document.getElementById('view-water-distribution').addEventListener('click', () => showOnly('waterDistribution'));
        document.getElementById('view-primary-fan').addEventListener('click', () => showOnly('primaryFan'));
        document.getElementById('view-secondary-fan').addEventListener('click', () => showOnly('secondaryFan'));
        document.getElementById('view-primary-air-inlet').addEventListener('click', () => showOnly('primaryAirInlet'));
        document.getElementById('view-cooled-air-outlet').addEventListener('click', () => showOnly('cooledAirOutlet'));
        document.getElementById('view-secondary-air-inlet').addEventListener('click', () => showOnly('secondaryAirInlet'));
        document.getElementById('view-humid-air-exhaust').addEventListener('click', () => showOnly('humidAirExhaust'));

        window.addEventListener('click', onMouseClick, false);
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Animate water particles
            if (components.waterParticles && components.waterParticles.visible) {
                const particles = components.waterParticles;
                if (particles && particles.geometry && particles.geometry.attributes && particles.geometry.attributes.position) {
                    const positions = particles.geometry.attributes.position.array;
                    const paths = particles.userData.paths;
                    const particlesPerPath = Math.floor(particles.userData.progress.length / paths.length);

                    for (let i = 0; i < particles.userData.progress.length; i++) {
                        const pathIndex = Math.floor(i / particlesPerPath);
                        const currentPath = paths[pathIndex];
                        if (!currentPath) continue;

                        particles.userData.progress[i] = (particles.userData.progress[i] + 0.005) % 1; // Water speed
                        const p = currentPath.getPointAt(particles.userData.progress[i]);
                        positions[i * 3] = p.x + (Math.random() - 0.5) * 0.1;
                        positions[i * 3 + 1] = p.y + (Math.random() - 0.5) * 0.1;
                        positions[i * 3 + 2] = p.z + (Math.random() - 0.5) * 0.1;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                }
            }

            // Animate primary air particles
            if (components.primaryAirParticles && components.primaryAirParticles.visible) {
                const particles = components.primaryAirParticles;
                if (particles && particles.geometry && particles.geometry.attributes && particles.geometry.attributes.position) {
                    const positions = particles.geometry.attributes.position.array;
                    const paths = particles.userData.paths;
                    const particlesPerPath = Math.floor(particles.userData.progress.length / paths.length);

                    for (let i = 0; i < particles.userData.progress.length; i++) {
                        const pathIndex = Math.floor(i / particlesPerPath);
                        const currentPath = paths[pathIndex];
                        if (!currentPath) continue;

                        particles.userData.progress[i] = (particles.userData.progress[i] + 0.008) % 1; // Primary air speed
                        const p = currentPath.getPointAt(particles.userData.progress[i]);
                        positions[i * 3] = p.x + (Math.random() - 0.5) * 0.2;
                        positions[i * 3 + 1] = p.y + (Math.random() - 0.5) * 0.2;
                        positions[i * 3 + 2] = p.z + (Math.random() - 0.5) * 0.2;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                }
            }

            // Animate secondary air particles
            if (components.secondaryAirParticles && components.secondaryAirParticles.visible) {
                const particles = components.secondaryAirParticles;
                if (particles && particles.geometry && particles.geometry.attributes && particles.geometry.attributes.position) {
                    const positions = particles.geometry.attributes.position.array;
                    const paths = particles.userData.paths;
                    const particlesPerPath = Math.floor(particles.userData.progress.length / paths.length);

                    for (let i = 0; i < particles.userData.progress.length; i++) {
                        const pathIndex = Math.floor(i / particlesPerPath);
                        const currentPath = paths[pathIndex];
                        if (!currentPath) continue;

                        particles.userData.progress[i] = (particles.userData.progress[i] + 0.007) % 1; // Secondary air speed
                        const p = currentPath.getPointAt(particles.userData.progress[i]);
                        positions[i * 3] = p.x + (Math.random() - 0.5) * 0.2;
                        positions[i * 3 + 1] = p.y + (Math.random() - 0.5) * 0.2;
                        positions[i * 3 + 2] = p.z + (Math.random() - 0.5) * 0.2;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                }
            }

            // Animate primary fan blades
            if (components.primaryFan && components.primaryFan.visible && components.primaryFan.children.length > 1) {
                // Filter for actual blade meshes, not the housing
                const fanBlades = components.primaryFan.children.filter(child => child.geometry && child.geometry.type === 'ExtrudeGeometry');
                fanBlades.forEach(blade => {
                    blade.rotation.z += 0.1;
                });
            }

            // Animate secondary fan blades
            if (components.secondaryFan && components.secondaryFan.visible && components.secondaryFan.children.length > 1) {
                // Filter for actual blade meshes, not the housing
                const fanBlades = components.secondaryFan.children.filter(child => child.geometry && child.geometry.type === 'ExtrudeGeometry');
                fanBlades.forEach(blade => {
                    blade.rotation.y += 0.1; // Rotate along Y for side fan
                });
            }

            renderer.render(scene, camera);
        }
        
        window.onload = function () {
            createComponents();
            showOnly('full');
            animate(); 
        }
    </script>
</body>
</html>
