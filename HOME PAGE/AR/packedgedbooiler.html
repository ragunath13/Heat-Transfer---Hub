<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Packaged Boiler</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif; /* Using Inter font */
        }
        canvas {
            display: block;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px; /* Rounded corners */
            max-width: 600px;
            text-align: center;
            transition: all 0.5s ease;
            z-index: 100;
            border: 1px solid #8bc34a; /* Light Green border */
            box-shadow: 0 4px 15px rgba(139, 195, 74, 0.2); /* Light Green shadow */
        }
        .info-panel h3 {
            margin-top: 0;
            color: #8bc34a; /* Light Green title */
            font-size: 22px;
        }
        .info-panel p {
            margin-bottom: 0;
            font-size: 16px;
            line-height: 1.5;
        }
        #title {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            z-index: 100;
            border-radius: 8px; /* Rounded corners */
        }
        #controls {
            position: absolute;
            top: 70px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid #8bc34a; /* Light Green border */
            padding: 8px 12px;
            border-radius: 4px; /* Rounded corners */
            cursor: pointer;
            min-width: 180px; /* Increased width for better text display */
            text-align: left;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            box-shadow: 0 2px 5px rgba(139, 195, 74, 0.1); /* Subtle shadow */
        }
        button:hover {
            background-color: rgba(139, 195, 74, 0.2); /* Lighter green on hover */
            border-color: #c5e1a5; /* Lighter border on hover */
        }
        .component-button {
            display: flex;
            align-items: center;
        }
        .component-button .color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            display: inline-block;
            border: 1px solid rgba(255, 255, 255, 0.3); /* Small border for visibility */
        }
    </style>
</head>
<body>
    <div id="title">Packaged Boiler - Click on any component</div>
    <div id="controls">
        <button id="reset-view">Show Full Assembly</button>
        <button id="toggle-casing"><span class="color-indicator" style="background-color: #616161;"></span>Toggle Outer Casing</button>
        <button id="section-view">Section View</button>
        <div style="margin-top: 10px; color: white; font-size: 14px;">Component Quick View:</div>
        <button id="view-boiler-shell"><span class="color-indicator" style="background-color: #bdbdbd;"></span>View Boiler Shell</button>
        <button id="view-furnace"><span class="color-indicator" style="background-color: #f44336;"></span>View Furnace</button>
        <button id="view-fire-tubes"><span class="color-indicator" style="background-color: #ff9800;"></span>View Fire Tubes</button>
        <button id="view-burner"><span class="color-indicator" style="background-color: #757575;"></span>View Burner</button>
        <button id="view-control-cabinet"><span class="color-indicator" style="background-color: #424242;"></span>View Control Cabinet</button>
        <button id="view-feedwater-pump"><span class="color-indicator" style="background-color: #ffeb3b;"></span>View Feedwater Pump</button>
        <button id="view-nozzles"><span class="color-indicator" style="background-color: #ffb74d;"></span>View Nozzles</button>
    </div>
    <div id="info-panel" class="info-panel" style="display: none;">
        <h3 id="component-title">Component</h3>
        <p id="component-description">Description will appear here</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/curves/CatmullRomCurve3.js"></script>
    <script>
        // Main variables
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Black background

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 40); // Initial camera position, slightly elevated
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        document.body.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth camera movement
        controls.dampingFactor = 0.05;
        controls.target.set(0, 5, 0); // Point camera slightly towards the center
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Soft ambient light
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Main light source
        directionalLight.position.set(10, 20, 15);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024; // default
        directionalLight.shadow.mapSize.height = 1024; // default
        directionalLight.shadow.camera.near = 0.5; // default
        directionalLight.shadow.camera.far = 100; // default
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);
        
        const backLight = new THREE.DirectionalLight(0xffffff, 0.3); // Secondary light
        backLight.position.set(-10, -20, -15);
        scene.add(backLight);
        
        // Interaction tools
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Animation variables
        let animationId = null;
        let targetPosition = null;
        let targetLookAt = null;
        let isAnimating = false;
        
        // Section view
        let isSectionView = false;
        // Section plane for cutting through the model (initially cutting along XZ plane)
        const sectionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); 
        const sectionHelper = new THREE.PlaneHelper(sectionPlane, 20, 0xff0000); // Red helper plane
        sectionHelper.visible = false;
        scene.add(sectionHelper);
        renderer.localClippingEnabled = false; // Disable clipping by default

        // Component storage
        const components = {
            outerCasing: null,
            boilerShell: null,
            furnace: null,
            fireTubes: null,
            burner: null,
            controlCabinet: null,
            feedwaterPump: null,
            nozzles: null,
            fluidFlowGas: null, 
            fluidFlowWater: null, 
            fluidFlowSteam: null,
            fullAssembly: null
        };
        
        // Component information (descriptions, colors, etc.)
        const componentInfo = {
            'outerCasing': {
                title: 'Outer Casing / Enclosure',
                description: 'The external rectangular enclosure that houses all the boiler components, providing protection, insulation, and a compact, integrated unit.',
                color: 0x616161, // Dark Grey
                internal: false
            },
            'boilerShell': {
                title: 'Boiler Shell',
                description: 'The main cylindrical pressure vessel containing the water and steam, and the internal heat exchange tubes.',
                color: 0xbdbdbd, // Light Grey
                internal: true
            },
            'furnace': {
                title: 'Furnace / Combustion Chamber',
                description: 'The primary chamber inside the boiler shell where fuel is burned to produce hot combustion gases. In a packaged boiler, it\'s often a large, internal flue.',
                color: 0xf44336, // Red
                internal: true
            },
            'fireTubes': {
                title: 'Fire Tubes',
                description: 'A series of tubes running through the water-filled boiler shell. Hot combustion gases from the furnace pass through these tubes, transferring heat to the surrounding water.',
                color: 0xff9800, // Orange
                internal: true
            },
            'burner': {
                title: 'Burner',
                description: 'The device that mixes fuel (gas or oil) with air and ignites it to create a flame within the furnace. It is typically mounted at one end of the boiler.',
                color: 0x757575, // Medium Grey
                internal: false
            },
            'controlCabinet': {
                title: 'Control Cabinet',
                description: 'An integrated enclosure containing the electrical controls, safety devices, and instrumentation for automated and safe operation of the boiler.',
                color: 0x424242, // Dark Grey
                internal: false
            },
            'feedwaterPump': {
                title: 'Feedwater Pump',
                description: 'A pump that supplies treated water from the feedwater tank to the boiler, maintaining the correct water level for steam generation.',
                color: 0xffeb3b, // Yellow
                internal: false
            },
            'nozzles': {
                title: 'Nozzles / Ports',
                description: 'Connection points on the boiler shell for steam outlet, feedwater inlet, blowdown, safety valves, and other ancillary equipment.',
                color: 0xffb74d, // Light Orange
                internal: false
            }
        };

        // Global constants for boiler dimensions
        const casingWidth = 30;
        const casingHeight = 20;
        const casingDepth = 15;
        const casingThickness = 0.5;

        const shellRadius = 7;
        const shellLength = casingWidth * 0.7; // Shorter than casing to allow space for burner/pump
        const shellOffsetZ = (casingDepth / 2) - (shellRadius + 2); // Offset from front for burner

        const furnaceRadius = 2.5;
        const furnaceLength = shellLength * 0.8;

        const tubeRadius = 0.3;
        const numTubeRows = 5;
        const numTubeCols = 5;
        const tubeSpacing = 1.2;

        const burnerLength = 5;
        const burnerRadius = 3;

        const controlCabinetWidth = 6;
        const controlCabinetHeight = 8;
        const controlCabinetDepth = 3;

        const pumpRadius = 1.5;
        const pumpHeight = 3;

        const nozzleRadius = 0.6;
        const nozzleLength = 1.5;

        // Global constants for fluid particles
        const particleSizeWater = 0.2;
        const particleSizeSteam = 0.3;
        const particleSizeGas = 0.4;


        // Create all components of the packaged boiler
        function createComponents() {
            // Outer Casing
            const casingMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.outerCasing.color,
                metalness: 0.5,
                roughness: 0.5,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide // Render inside out for better transparency effect
            });
            components.outerCasing = new THREE.Mesh(
                new THREE.BoxGeometry(casingWidth, casingHeight, casingDepth),
                casingMaterial
            );
            components.outerCasing.userData = { type: 'outerCasing' };

            // Boiler Shell (internal)
            const shellMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.boilerShell.color,
                metalness: 0.7,
                roughness: 0.3,
                transparent: true,
                opacity: 0.7, // Semi-transparent to see inside
                clearcoat: 0.5,
                side: THREE.DoubleSide
            });
            components.boilerShell = new THREE.Mesh(
                new THREE.CylinderGeometry(shellRadius, shellRadius, shellLength, 32),
                shellMaterial
            );
            components.boilerShell.rotation.x = Math.PI / 2; // Orient along Z-axis
            components.boilerShell.position.z = shellOffsetZ - casingDepth / 2 + shellLength / 2; // Position inside casing
            components.boilerShell.userData = { type: 'boilerShell' };

            // Furnace
            const furnaceMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.furnace.color,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 0.3
            });
            components.furnace = new THREE.Mesh(
                new THREE.CylinderGeometry(furnaceRadius, furnaceRadius, furnaceLength, 32),
                furnaceMaterial
            );
            components.furnace.rotation.x = Math.PI / 2;
            components.furnace.position.z = components.boilerShell.position.z - shellLength / 2 + furnaceLength / 2;
            components.furnace.userData = { type: 'furnace' };

            // Fire Tubes
            components.fireTubes = new THREE.Group();
            const fireTubeMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.fireTubes.color,
                metalness: 0.6,
                roughness: 0.4
            });

            // Arrange tubes in a grid around the furnace
            const offset = (numTubeRows - 1) * tubeSpacing / 2;
            for (let i = 0; i < numTubeRows; i++) {
                for (let j = 0; j < numTubeCols; j++) {
                    const xPos = (i * tubeSpacing) - offset;
                    const yPos = (j * tubeSpacing) - offset;

                    // Ensure tubes are outside the furnace radius and within shell
                    if (Math.sqrt(xPos * xPos + yPos * yPos) > furnaceRadius + tubeRadius + 0.5 &&
                        Math.sqrt(xPos * xPos + yPos * yPos) < shellRadius - tubeRadius - 0.5) {
                        const tube = new THREE.Mesh(
                            new THREE.CylinderGeometry(tubeRadius, tubeRadius, furnaceLength * 0.9, 16), // Slightly shorter than furnace
                            fireTubeMaterial
                        );
                        tube.rotation.x = Math.PI / 2;
                        tube.position.set(xPos, yPos, components.furnace.position.z + furnaceLength * 0.05); // Aligned with furnace
                        tube.userData = { type: 'fireTubes' };
                        components.fireTubes.add(tube);
                    }
                }
            }

            // Burner
            const burnerMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.burner.color,
                metalness: 0.6,
                roughness: 0.4
            });
            components.burner = new THREE.Mesh(
                new THREE.CylinderGeometry(burnerRadius, burnerRadius * 0.8, burnerLength, 32),
                burnerMaterial
            );
            components.burner.rotation.x = Math.PI / 2;
            components.burner.position.z = components.furnace.position.z - furnaceLength / 2 - burnerLength / 2; // Front of furnace
            components.burner.userData = { type: 'burner' };

            // Control Cabinet
            const cabinetMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.controlCabinet.color,
                metalness: 0.5,
                roughness: 0.5,
                clearcoat: 0.2
            });
            components.controlCabinet = new THREE.Mesh(
                new THREE.BoxGeometry(controlCabinetWidth, controlCabinetHeight, controlCabinetDepth),
                cabinetMaterial
            );
            components.controlCabinet.position.set(casingWidth / 2 + controlCabinetWidth / 2, 0, 0); // Side of casing
            components.controlCabinet.userData = { type: 'controlCabinet' };

            // Feedwater Pump
            const pumpMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.feedwaterPump.color,
                metalness: 0.6,
                roughness: 0.4
            });
            components.feedwaterPump = new THREE.Mesh(
                new THREE.CylinderGeometry(pumpRadius, pumpRadius, pumpHeight, 16),
                pumpMaterial
            );
            components.feedwaterPump.position.set(-casingWidth / 2 - pumpRadius * 2, -casingHeight / 2 + pumpHeight / 2, casingDepth / 4); // Bottom-left-front
            components.feedwaterPump.userData = { type: 'feedwaterPump' };

            // Nozzles
            components.nozzles = new THREE.Group();
            const nozzleMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.nozzles.color,
                metalness: 0.7,
                roughness: 0.3
            });
            const flangeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x616161, // Darker grey for flange
                metalness: 0.6,
                roughness: 0.4
            });

            // Steam Outlet Nozzle (top of shell)
            const steamNozzle = new THREE.Mesh(new THREE.CylinderGeometry(nozzleRadius, nozzleRadius, nozzleLength, 16), nozzleMaterial);
            steamNozzle.position.set(0, components.boilerShell.position.y + shellRadius + nozzleLength / 2, components.boilerShell.position.z);
            steamNozzle.userData = { type: 'nozzles' };
            components.nozzles.add(steamNozzle);

            const steamFlange = new THREE.Mesh(new THREE.CylinderGeometry(nozzleRadius * 1.5, nozzleRadius * 1.5, 0.5, 16), flangeMaterial);
            steamFlange.position.set(0, components.boilerShell.position.y + shellRadius + nozzleLength + 0.25, components.boilerShell.position.z);
            steamFlange.userData = { type: 'nozzles' };
            components.nozzles.add(steamFlange);

            // Feedwater Inlet Nozzle (side of shell)
            const feedwaterNozzle = new THREE.Mesh(new THREE.CylinderGeometry(nozzleRadius * 0.7, nozzleRadius * 0.7, nozzleLength, 16), nozzleMaterial);
            feedwaterNozzle.rotation.z = Math.PI / 2;
            feedwaterNozzle.position.set(components.boilerShell.position.x + shellRadius + nozzleLength / 2, components.boilerShell.position.y - shellRadius / 2, components.boilerShell.position.z - shellLength / 4);
            feedwaterNozzle.userData = { type: 'nozzles' };
            components.nozzles.add(feedwaterNozzle);

            const feedwaterFlange = new THREE.Mesh(new THREE.CylinderGeometry(nozzleRadius * 1.05, nozzleRadius * 1.05, 0.5, 16), flangeMaterial);
            feedwaterFlange.rotation.z = Math.PI / 2;
            feedwaterFlange.position.set(components.boilerShell.position.x + shellRadius + nozzleLength + 0.25, components.boilerShell.position.y - shellRadius / 2, components.boilerShell.position.z - shellLength / 4);
            feedwaterFlange.userData = { type: 'nozzles' };
            components.nozzles.add(feedwaterFlange);

            // Blowdown Nozzle (bottom of shell)
            const blowdownNozzle = new THREE.Mesh(new THREE.CylinderGeometry(nozzleRadius * 0.6, nozzleRadius * 0.6, nozzleLength, 16), nozzleMaterial);
            blowdownNozzle.position.set(0, components.boilerShell.position.y - shellRadius - nozzleLength / 2, components.boilerShell.position.z + shellLength / 4);
            blowdownNozzle.userData = { type: 'nozzles' };
            components.nozzles.add(blowdownNozzle);

            const blowdownFlange = new THREE.Mesh(new THREE.CylinderGeometry(nozzleRadius * 0.9, nozzleRadius * 0.9, 0.5, 16), flangeMaterial);
            blowdownFlange.position.set(0, components.boilerShell.position.y - shellRadius - nozzleLength - 0.25, components.boilerShell.position.z + shellLength / 4);
            blowdownFlange.userData = { type: 'nozzles' };
            components.nozzles.add(blowdownFlange);


            // Fluid Flow Animation
            components.fluidFlowGas = new THREE.Group();
            components.fluidFlowWater = new THREE.Group();
            components.fluidFlowSteam = new THREE.Group();

            const numGasParticles = 150;
            const numWaterParticles = 200;
            const numSteamParticles = 50;
            
            const hotGasColor = 0xffa500; // Orange for hot gas
            const waterColor = 0x00bfff; // Deep Sky Blue for water
            const steamColor = 0xffffff; // White for steam

            function createFluidParticles(color, numParticles, size) {
                const positions = new Float32Array(numParticles * 3);
                const particles = new THREE.BufferAttribute(positions, 3);
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', particles);

                const material = new THREE.PointsMaterial({
                    color: color,
                    size: size,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.7,
                    sizeAttenuation: true
                });

                const points = new THREE.Points(geometry, material);
                points.userData.progress = new Array(numParticles).fill(0).map(() => Math.random()); // Random initial progress
                return points;
            }

            // Hot Gas Flow (from burner, through furnace, through fire tubes)
            const gasParticles = createFluidParticles(hotGasColor, numGasParticles, particleSizeGas);
            gasParticles.userData.curves = [];
            
            // Path through furnace
            const furnaceGasPathPoints = [
                components.burner.position.clone().add(new THREE.Vector3(0, 0, burnerLength / 2)),
                components.furnace.position.clone().add(new THREE.Vector3(0, 0, furnaceLength / 2))
            ];
            gasParticles.userData.curves.push(new THREE.CatmullRomCurve3(furnaceGasPathPoints));

            // Paths through fire tubes (simplified, just a few representative)
            components.fireTubes.children.slice(0, 5).forEach(tube => { // Take first 5 tubes
                const tubeStart = tube.position.clone().add(new THREE.Vector3(0, 0, -furnaceLength * 0.45));
                const tubeEnd = tube.position.clone().add(new THREE.Vector3(0, 0, furnaceLength * 0.45));
                gasParticles.userData.curves.push(new THREE.CatmullRomCurve3([tubeStart, tubeEnd]));
            });
            components.fluidFlowGas.add(gasParticles);

            // Water Circulation (around tubes, convection)
            const waterParticles = createFluidParticles(waterColor, numWaterParticles, particleSizeWater);
            waterParticles.userData.flowDirection = new Array(numWaterParticles).fill(0).map(() => new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize());
            components.fluidFlowWater.add(waterParticles);

            // Steam Generation (bubbles rising from water level)
            const steamParticles = createFluidParticles(steamColor, numSteamParticles, particleSizeSteam);
            components.fluidFlowSteam.add(steamParticles);

            components.fluidFlowGas.visible = false; 
            components.fluidFlowWater.visible = false; 
            components.fluidFlowSteam.visible = false; 
            scene.add(components.fluidFlowGas);
            scene.add(components.fluidFlowWater);
            scene.add(components.fluidFlowSteam);


            // Full assembly
            components.fullAssembly = new THREE.Group();
            components.fullAssembly.add(components.outerCasing);
            components.fullAssembly.add(components.boilerShell);
            components.fullAssembly.add(components.furnace);
            components.fullAssembly.add(components.fireTubes);
            components.fullAssembly.add(components.burner);
            components.fullAssembly.add(components.controlCabinet);
            components.fullAssembly.add(components.feedwaterPump);
            components.fullAssembly.add(components.nozzles);
            
            scene.add(components.fullAssembly);
        }

        // Initialize components
        createComponents();

        // Show only specific component(s)
        function showOnly(componentType) {
            // Hide all components first
            Object.values(components).forEach(comp => {
                if (comp && comp !== components.fullAssembly && comp !== components.fluidFlowGas && comp !== components.fluidFlowWater && comp !== components.fluidFlowSteam) {
                    comp.visible = false;
                }
            });
            
            // Hide fluid animations by default when changing views
            components.fluidFlowGas.visible = false;
            components.fluidFlowWater.visible = false;
            components.fluidFlowSteam.visible = false;

            // Show the requested component(s)
            if (componentType === 'outerCasing') {
                components.outerCasing.visible = true;
            } else if (componentType === 'boilerShell') {
                components.boilerShell.visible = true;
                components.furnace.visible = true; // Context
                components.fireTubes.visible = true; // Context
                components.nozzles.visible = true; // Context
                components.fluidFlowWater.visible = true; // Show water flow
                components.fluidFlowSteam.visible = true; // Show steam flow
            } else if (componentType === 'furnace') {
                components.furnace.visible = true;
                components.burner.visible = true; // Context
                components.fireTubes.visible = true; // Context
                components.fluidFlowGas.visible = true; // Show gas flow
            } else if (componentType === 'fireTubes') {
                components.fireTubes.visible = true;
                components.furnace.visible = true; // Context
                components.boilerShell.visible = true; // Context
                components.fluidFlowGas.visible = true; // Show gas flow
                components.fluidFlowWater.visible = true; // Show water flow
                components.fluidFlowSteam.visible = true; // Show steam flow
            } else if (componentType === 'burner') {
                components.burner.visible = true;
                components.furnace.visible = true; // Context
                components.fluidFlowGas.visible = true; // Show gas flow
            } else if (componentType === 'controlCabinet') {
                components.controlCabinet.visible = true;
            } else if (componentType === 'feedwaterPump') {
                components.feedwaterPump.visible = true;
                components.nozzles.visible = true; // Context
            } else if (componentType === 'nozzles') {
                components.nozzles.visible = true;
                components.boilerShell.visible = true; // Context
            } else if (componentType === 'full') {
                Object.values(components).forEach(comp => {
                    if (comp && comp !== components.fluidFlowGas && comp !== components.fluidFlowWater && comp !== components.fluidFlowSteam) comp.visible = true;
                });
                // Show all fluid animations in full view by default
                components.fluidFlowGas.visible = true;
                components.fluidFlowWater.visible = true;
                components.fluidFlowSteam.visible = true;
            }
            
            // Update info panel if showing single component
            if (componentType !== 'full' && componentInfo[componentType]) {
                document.getElementById('component-title').textContent = componentInfo[componentType].title;
                document.getElementById('component-description').textContent = componentInfo[componentType].description;
                document.getElementById('info-panel').style.display = 'block';
            } else {
                document.getElementById('info-panel').style.display = 'none';
            }
            
            // Focus camera on the shown component(s)
            let targetObject;
            if (componentType === 'outerCasing') targetObject = components.outerCasing;
            else if (componentType === 'boilerShell') targetObject = components.boilerShell;
            else if (componentType === 'furnace') targetObject = components.furnace;
            else if (componentType === 'fireTubes') targetObject = components.fireTubes;
            else if (componentType === 'burner') targetObject = components.burner;
            else if (componentType === 'controlCabinet') targetObject = components.controlCabinet;
            else if (componentType === 'feedwaterPump') targetObject = components.feedwaterPump;
            else if (componentType === 'nozzles') targetObject = components.nozzles;
            else targetObject = components.fullAssembly;
            
            animateCameraToComponent(targetObject);
        }

        // Camera animation to focus on object
        function animateCameraToComponent(object) {
            if (isAnimating) return;
            
            isAnimating = true;
            controls.enabled = false; // Disable orbit controls during animation
            
            const boundingBox = new THREE.Box3().setFromObject(object);
            const size = boundingBox.getSize(new THREE.Vector3());
            const center = boundingBox.getCenter(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 1.8; // Adjust multiplier for desired zoom level
            
            // Calculate target position for camera
            const currentCameraPosition = camera.position.clone();
            const currentLookAt = controls.target.clone();

            // Determine a direction from the object's center to place the camera
            // Default to looking from front-right-top if object is at origin
            let direction = new THREE.Vector3().subVectors(currentCameraPosition, center).normalize();
            if (direction.length() === 0) direction.set(0.5, 0.5, 1).normalize(); // Fallback if camera is at center

            targetPosition = new THREE.Vector3().copy(center).add(direction.multiplyScalar(distance));
            targetLookAt = center.clone();
            
            animateCamera();
        }

        function animateCamera() {
            if (!targetPosition || !targetLookAt) return;
            
            const moveSpeed = 0.05; // Slower for smoother transition
            const lookSpeed = 0.05;
            
            camera.position.lerp(targetPosition, moveSpeed);
            controls.target.lerp(targetLookAt, lookSpeed);
            
            const positionDiff = camera.position.distanceTo(targetPosition);
            const lookDiff = controls.target.distanceTo(targetLookAt);
            
            if (positionDiff < 0.1 && lookDiff < 0.1) { // Threshold for animation end
                camera.position.copy(targetPosition);
                controls.target.copy(targetLookAt);
                isAnimating = false;
                controls.enabled = true; // Re-enable orbit controls
                return;
            }
            
            animationId = requestAnimationFrame(animateCamera);
        }

        // Toggle casing visibility
        function toggleCasingVisibility() {
            components.outerCasing.visible = !components.outerCasing.visible;
            document.getElementById('toggle-casing').innerHTML = 
                `<span class="color-indicator" style="background-color: #${new THREE.Color(componentInfo.outerCasing.color).getHexString()};"></span>` +
                (components.outerCasing.visible ? 'Hide Outer Casing' : 'Show Outer Casing');
        }

        // Toggle section view
        function toggleSectionView() {
            isSectionView = !isSectionView;
            renderer.localClippingEnabled = isSectionView;
            sectionHelper.visible = isSectionView;
            
            // Toggle fluid visibility based on section view
            components.fluidFlowGas.visible = isSectionView;
            components.fluidFlowWater.visible = isSectionView;
            components.fluidFlowSteam.visible = isSectionView;

            scene.traverse(child => {
                if (child.isMesh) {
                    // Apply clipping planes only to components that are part of the main assembly
                    if (child.parent && child.parent.userData.type === 'fullAssembly' || child.userData.type === 'outerCasing' || child.userData.type === 'boilerShell' || child.userData.type === 'furnace' || child.userData.type === 'fireTubes') {
                         child.material.clippingPlanes = isSectionView ? [sectionPlane] : null;
                    } else {
                        child.material.clippingPlanes = null;
                    }
                    child.material.needsUpdate = true;
                }
            });
            
            document.getElementById('section-view').textContent = 
                isSectionView ? 'Full View' : 'Section View';
        }

        // Handle mouse clicks
        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Calculate objects intersecting the ray
            const intersects = raycaster.intersectObjects(scene.children, true); // true for recursive check
            
            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                // Traverse up the hierarchy to find the main component group
                while (clickedObject && !clickedObject.userData.type && clickedObject.parent) {
                    clickedObject = clickedObject.parent;
                }
                
                if (clickedObject && clickedObject.userData.type) {
                    const componentType = clickedObject.userData.type;
                    showOnly(componentType);
                }
            }
        }

        // Set up UI controls
        document.getElementById('toggle-casing').addEventListener('click', toggleCasingVisibility);
        document.getElementById('section-view').addEventListener('click', toggleSectionView);
        document.getElementById('reset-view').addEventListener('click', () => showOnly('full'));
        document.getElementById('view-boiler-shell').addEventListener('click', () => showOnly('boilerShell'));
        document.getElementById('view-furnace').addEventListener('click', () => showOnly('furnace'));
        document.getElementById('view-fire-tubes').addEventListener('click', () => showOnly('fireTubes'));
        document.getElementById('view-burner').addEventListener('click', () => showOnly('burner'));
        document.getElementById('view-control-cabinet').addEventListener('click', () => showOnly('controlCabinet'));
        document.getElementById('view-feedwater-pump').addEventListener('click', () => showOnly('feedwaterPump'));
        document.getElementById('view-nozzles').addEventListener('click', () => showOnly('nozzles'));

        window.addEventListener('click', onMouseClick, false);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate); // Request next frame
            controls.update(); // Update orbit controls

            // Animate fluid particles if visible
            if (components.fluidFlowGas.visible) {
                const gasParticles = components.fluidFlowGas.children[0];
                const gasPositions = gasParticles.geometry.attributes.position.array;
                const gasCurves = gasParticles.userData.curves;
                const particlesPerCurve = Math.floor(gasParticles.userData.progress.length / gasCurves.length);

                for (let i = 0; i < gasParticles.userData.progress.length; i++) {
                    const curveIndex = Math.floor(i / particlesPerCurve);
                    const currentCurve = gasCurves[curveIndex];
                    if (!currentCurve) continue;

                    gasParticles.userData.progress[i] = (gasParticles.userData.progress[i] + 0.005) % 1; // Adjust speed
                    const p = currentCurve.getPointAt(gasParticles.userData.progress[i]);
                    gasPositions[i * 3] = p.x;
                    gasPositions[i * 3 + 1] = p.y;
                    gasPositions[i * 3 + 2] = p.z;
                }
                gasParticles.geometry.attributes.position.needsUpdate = true;
            }

            if (components.fluidFlowWater.visible) {
                const waterParticles = components.fluidFlowWater.children[0];
                const waterPositions = waterParticles.geometry.attributes.position.array;
                const numWaterParticles = waterParticles.userData.progress.length;
                const waterLevel = components.boilerShell.position.y + shellRadius * 0.5; // Approximate water level
                const shellMinZ = components.boilerShell.position.z - shellLength / 2;
                const shellMaxZ = components.boilerShell.position.z + shellLength / 2;

                for (let i = 0; i < numWaterParticles; i++) {
                    waterParticles.userData.progress[i] += 0.01; // Simple random movement

                    if (waterParticles.userData.progress[i] > 1) {
                        waterParticles.userData.progress[i] = 0;
                        // Reset particle to a random position within the water space
                        waterPositions[i * 3] = (Math.random() * 2 - 1) * (shellRadius - tubeRadius * 2); // X
                        waterPositions[i * 3 + 1] = (Math.random() * waterLevel) - waterLevel / 2; // Y (below water level)
                        waterPositions[i * 3 + 2] = (Math.random() * (shellLength * 0.8)) - (shellLength * 0.4) + components.boilerShell.position.z; // Z (within shell length)
                    } else {
                        // Simulate slight random movement for convection
                        waterPositions[i * 3] += (Math.random() - 0.5) * 0.1;
                        waterPositions[i * 3 + 1] += (Math.random() - 0.5) * 0.1;
                        waterPositions[i * 3 + 2] += (Math.random() - 0.5) * 0.1;

                        // Keep particles within shell boundaries (simplified)
                        const currentRadius = Math.sqrt(waterPositions[i * 3] * waterPositions[i * 3] + waterPositions[i * 3 + 1] * waterPositions[i * 3 + 1]);
                        if (currentRadius > shellRadius - particleSizeWater) {
                             waterPositions[i * 3] *= (shellRadius - particleSizeWater) / currentRadius;
                             waterPositions[i * 3 + 1] *= (shellRadius - particleSizeWater) / currentRadius;
                        }
                        waterPositions[i * 3 + 2] = Math.max(shellMinZ + 0.5, Math.min(shellMaxZ - 0.5, waterPositions[i * 3 + 2]));
                    }
                }
                waterParticles.geometry.attributes.position.needsUpdate = true;
            }

            if (components.fluidFlowSteam.visible) {
                const steamParticles = components.fluidFlowSteam.children[0];
                const steamPositions = steamParticles.geometry.attributes.position.array;
                const numSteamParticles = steamParticles.userData.progress.length;
                const waterLevel = components.boilerShell.position.y + shellRadius * 0.5; // Approximate water level
                const steamSpaceTop = components.boilerShell.position.y + shellRadius - 0.5; // Top of steam space
                const shellMinZ = components.boilerShell.position.z - shellLength / 2;
                const shellMaxZ = components.boilerShell.position.z + shellLength / 2;

                for (let i = 0; i < numSteamParticles; i++) {
                    steamParticles.userData.progress[i] += 0.02; // Steam rises faster

                    if (steamParticles.userData.progress[i] > 1) {
                        steamParticles.userData.progress[i] = 0;
                        // Reset particle to just below water level
                        steamPositions[i * 3] = (Math.random() * 2 - 1) * (shellRadius - tubeRadius * 2); // X
                        steamPositions[i * 3 + 1] = waterLevel - Math.random() * 0.5; // Y (just below water surface)
                        steamPositions[i * 3 + 2] = (Math.random() * (shellLength * 0.8)) - (shellLength * 0.4) + components.boilerShell.position.z; // Z
                    } else {
                        // Simulate rising steam bubbles
                        steamPositions[i * 3 + 1] += 0.2; // Rise upwards
                        steamPositions[i * 3] += (Math.random() - 0.5) * 0.05; // Slight horizontal drift
                        steamPositions[i * 3 + 2] += (Math.random() - 0.5) * 0.05; // Slight depth drift

                        // Keep particles within shell boundaries (simplified)
                        const currentRadius = Math.sqrt(steamPositions[i * 3] * steamPositions[i * 3] + steamPositions[i * 3 + 1] * steamPositions[i * 3 + 1]);
                        if (currentRadius > shellRadius - particleSizeSteam) {
                             steamPositions[i * 3] *= (shellRadius - particleSizeSteam) / currentRadius;
                             steamPositions[i * 3 + 1] *= (shellRadius - particleSizeSteam) / currentRadius;
                        }
                        steamPositions[i * 3 + 2] = Math.max(shellMinZ + 0.5, Math.min(shellMaxZ - 0.5, steamPositions[i * 3 + 2]));
                    }
                }
                steamParticles.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera); // Render the scene
        }
        
        // Start the animation on window load.
        window.onload = function () {
            animate(); 
        }
    </script>
</body>
</html>
