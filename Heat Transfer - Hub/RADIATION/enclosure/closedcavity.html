<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radiation in Closed Cavities</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Audiowide|Rajdhani|Courier+New">
    <style>
        /* Base styles: Ensuring a deep, consistent black background */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box; /* Includes padding and border in the element's total width and height */
            /* Default background for elements unless specified - slightly off-black for depth */
            background-color: #0a0a0a;
        }

        body {
            background-color: #000000; /* Pure black for the main page background */
            font-family: 'Audiowide', cursive; /* Keeping the distinct, futuristic font */
            color: #d3d3d3; /* A standard light grey for excellent readability on dark backgrounds */
            line-height: 1.6; /* Improves readability of text blocks */
            overflow-x: hidden; /* Prevent horizontal scroll on some subtle effects */
        }

        /* Main Heading: Bold and energetic, central to the radiation theme */
        .main_heading {
            background: linear-gradient(to right, #f40166, #ff2a68, #ff0000); /* Vibrant red/pink/orange gradient */
            font-size: 50px; /* Consistent size for prominence */
            font-family: 'Courier New', monospace; /* A classic techy font */
            font-weight: 900; /* Extra bold for impact */
            color: #000000; /* Black text creates strong contrast on the gradient */
            text-align: center;
            padding: 50px;
            border-radius: 10px;
            box-shadow: 0 0 25px rgba(255, 110, 110, 0.7); /* Stronger, more defined glowing red shadow */
            margin: 30px auto; /* Centers the block and adds vertical spacing */
            max-width: 90%; /* Ensures responsiveness and readability on larger screens */
            will-change: box-shadow; /* Hint to browser for performance optimization */
        }

        /* General Paragraphs: Clean and readable, designed for content */
        p {
            font-size: 22px;
            font-family: 'Audiowide', cursive;
            text-align: center; /* Centered text within paragraphs */
            padding: 20px;
            margin: 25px auto; /* Centers the block and provides vertical spacing */
            max-width: 80%; /* Limits paragraph width for better readability */
            background-color: #1a1a1a; /* Slightly lighter charcoal for subtle visual distinction */
            border-radius: 10px;
            color: #b7b8b8; /* A muted grey for standard text */
            box-shadow: 0 0 8px rgba(255, 42, 104, 0.1); /* Very subtle, understated red glow */
            line-height: 1.7; /* Further improved readability */
        }

        /* Subtopic Headings: Consistent with the main radiation theme's subtopics */
        .subtopics {
            background-image: linear-gradient(58.2deg, rgba(255, 76, 10, 0.9) -3%, rgba(255, 0, 80, 0.8) 49.3%, rgba(255, 200, 0, 0.8) 97.7%); /* Intense, mixed-tone gradient */
            font-size: 28px;
            color: #ffffff;
            font-family: 'Audiowide', cursive;
            font-weight: bold;
            padding: 25px 40px;
            margin: 35px auto; /* Centered with generous spacing */
            max-width: 80%;
            text-align: center;
            border-radius: 15px; /* Softer radius for a less rigid feel */
            border: 2px solid #ff416c; /* A clear, vibrant red border */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
            transition: all 0.4s ease; /* All-encompassing smooth transition */
            will-change: transform, box-shadow, background;
            cursor: pointer;
        }

        .subtopics:hover {
            transform: scale(1.03) translateY(-3px); /* More noticeable lift and scale */
            background-image: linear-gradient(58.2deg, rgba(255, 0, 80, 0.95) -3%, rgba(255, 76, 10, 0.95) 49.3%, rgba(255, 200, 0, 0.95) 97.7%); /* Even more intense gradient on hover */
            color: #000000; /* Black text for strong contrast on hover */
            box-shadow: 0 0 45px rgba(255, 0, 80, 0.9); /* Enhanced, stronger glow on hover */
        }

        /* Definition Section: Standard content block with clear typography */
        .def {
            background-color: #111111; /* Consistent dark background */
            font-family: 'Audiowide', cursive;
            font-size: 22px; /* Consistent with general paragraphs */
            color: #b7b8b8;
            font-weight: normal; /* Standard weight for content, avoiding excessive boldness */
            text-align: center;
            padding: 30px;
            margin: 35px auto; /* Centered block with consistent spacing */
            max-width: 80%;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(255, 42, 104, 0.15); /* Subtle red glow */
            line-height: 1.7; /* Improved readability */
        }

        /* Fact Section: Highlighted and impactful, drawing attention with electric energy */
        .fact {
            background-color: #0d0d0d; /* Slightly darker than other blocks for more emphasis */
            font-size: 34px;
            color: #00e0ff; /* A vibrant, electric cyan for a striking highlight */
            font-weight: 900;
            font-family: 'Rajdhani', sans-serif; /* A bold, modern sans-serif */
            text-align: center;
            padding: 40px; /* Generous padding for emphasis */
            margin: 35px auto; /* Centers the block */
            max-width: 85%; /* Ensures good presentation on various screen sizes */
            border-radius: 12px;
            box-shadow: 0 0 35px rgba(0, 224, 255, 0.8); /* Intense, bright cyan glow for "energy" */
            transition: transform 0.3s ease, box-shadow 0.3s ease; /* Smooth interaction on hover */
            will-change: transform, box-shadow; /* Hint to browser for performance optimization */
        }

        .fact:hover {
            transform: scale(1.02); /* Slight scale on hover for a dynamic feel */
            box-shadow: 0 0 50px rgba(0, 224, 255, 1); /* Even brighter, stronger glow on hover */
        }

        /* Tech Points List: Professional styling with custom glowing bullets */
        .tech_points {
            list-style-type: none; /* Removes default bullet points */
            padding: 25px; /* Ample internal spacing */
            margin: 30px auto; /* Centers the block horizontally, adds vertical spacing */
            max-width: 85%; /* Ensures readability on large screens, responsive on small */
            background-color: #1a1a1a; /* A deep charcoal for subtle depth against pure black */
            border-radius: 12px; /* Softly rounded corners for a modern feel */
            box-shadow: 0 0 20px rgba(255, 0, 80, 0.15); /* A subtle, outward glow matching the radiation theme */
            color: #dadada; /* Light grey text for excellent contrast */
            font-family: 'Audiowide', cursive;
            font-size: 20px;
            text-align: left; /* Best for list readability */
            line-height: 1.5; /* Improves text readability */
        }

        .tech_points li {
            padding: 15px 0; /* Vertical padding for each list item */
            border-bottom: 1px solid rgba(255, 255, 255, 0.08); /* A very subtle, transparent line separator */
            position: relative; /* Necessary for positioning the custom bullet point */
            padding-left: 35px; /* Creates space for the custom bullet */
            transition: background-color 0.3s ease, transform 0.2s ease; /* Smooth hover effects */
        }

        .tech_points li:last-child {
            border-bottom: none; /* No separator for the very last item */
        }

        /* Custom glowing bullet point for each list item */
        .tech_points li::before {
            content: ''; /* Required for pseudo-elements */
            position: absolute;
            left: 0; /* Aligns to the left of the padding-left */
            top: 50%;
            transform: translateY(-50%); /* Vertically centers the bullet */
            width: 10px; /* Size of the bullet */
            height: 10px;
            border-radius: 50%; /* Makes it a perfect circle */
            background: linear-gradient(45deg, #00e0ff, #0072ff); /* A cool, vibrant electric cyan gradient */
            box-shadow: 0 0 12px rgba(0, 224, 255, 0.8); /* A strong, matching glow around the bullet */
        }

        .tech_points li:hover {
            background-color: #1a1a1a; /* Slightly lighter black on hover for subtle interaction */
            transform: translateX(5px); /* A subtle slide-right effect on hover */
        }

        /* Radiation in Closed Cavities specific visualizations */
        .cavity-visual-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 40px auto;
            max-width: 90%;
            background: #111111;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(255, 42, 104, 0.15); /* Subtle red glow for visual containers */
            position: relative;
        }

        .cavity-diagram {
            width: 300px;
            height: 300px;
            background-color: transparent;
            margin-bottom: 20px;
            position: relative;
            perspective: 1000px; /* For 3D effect */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cavity-box {
            width: 200px;
            height: 200px;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(20deg) rotateY(-30deg); /* Initial 3D orientation */
            transition: transform 0.5s ease-out;
        }

        .cavity-face {
            position: absolute;
            width: 200px;
            height: 200px;
            background-color: rgba(50, 50, 50, 0.8); /* Default gray for faces */
            border: 1px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Rajdhani', sans-serif;
            color: #eee;
            font-size: 18px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        /* Positioning of faces for a cube */
        .front { transform: rotateY(0deg) translateZ(100px); }
        .back { transform: rotateY(180deg) translateZ(100px); }
        .right { transform: rotateY(90deg) translateZ(100px); }
        .left { transform: rotateY(-90deg) translateZ(100px); }
        .top { transform: rotateX(90deg) translateZ(100px); }
        .bottom { transform: rotateX(-90deg) translateZ(100px); }

        .face-label {
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 14px;
            background-color: rgba(0,0,0,0.5);
            padding: 2px 5px;
            border-radius: 3px;
        }

        .face-temp {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 14px;
            color: #ffcc00;
            background-color: rgba(0,0,0,0.5);
            padding: 2px 5px;
            border-radius: 3px;
        }

        .radiation-particle {
            position: absolute;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background-color: #ffcc00; /* Yellow for particles */
            opacity: 0.8;
            z-index: 100; /* Ensure particles are on top */
            box-shadow: 0 0 5px #ffcc00;
            animation: particle-move linear infinite;
            transform-style: preserve-3d;
        }

        @keyframes particle-move {
            0% { transform: translate3d(var(--start-x), var(--start-y), var(--start-z)); opacity: 0.8; }
            100% { transform: translate3d(var(--end-x), var(--end-y), var(--end-z)); opacity: 0; }
        }

        .control-panel {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            width: 90%;
            max-width: 800px;
            padding: 15px;
            background-color: #1a1a1a;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 198, 255, 0.1);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #d3d3d3;
            font-family: 'Rajdhani', sans-serif;
            font-size: 18px;
            width: 150px; /* Fixed width for consistent layout */
        }

        .control-slider {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            background: linear-gradient(to right, #00e0ff, #ffcc00);
            border-radius: 4px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            margin-top: 5px;
        }

        .control-slider:hover {
            opacity: 1;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(255,255,255,0.8);
        }

        .control-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(255,255,255,0.8);
        }

        .current-value-display {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            color: #ffcc00;
            margin-top: 5px;
        }

        .result-display {
            font-family: 'Courier New', monospace;
            font-size: 28px;
            color: #00e0ff;
            text-shadow: 0 0 10px #00e0ff;
            margin-top: 20px;
            text-align: center;
        }

        /* Application examples grid */
        .app-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px auto;
            max-width: 90%;
        }

        .app-item {
            background: #1a1a1a; /* Consistent dark background for app items */
            padding: 20px;
            border-radius: 10px;
            transition: transform 0.3s ease, background 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 198, 255, 0.1); /* Subtle blue glow */
            cursor: pointer;
        }

        .app-item:hover {
            transform: scale(1.03) translateY(-5px); /* Slight lift and scale */
            background: #222222; /* Slightly lighter on hover */
            box-shadow: 0 8px 25px rgba(0, 198, 255, 0.4); /* More pronounced, lifted glow */
        }

        .app-icon {
            font-size: 40px;
            text-align: center;
            margin-bottom: 15px;
            color: #00e0ff; /* Electric cyan for icons */
            text-shadow: 0 0 10px rgba(0, 224, 255, 0.7); /* Glowing icon effect */
        }

        .app-title {
            font-family: 'Rajdhani', sans-serif;
            font-size: 22px;
            color: white;
            margin-bottom: 10px;
            text-align: center;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main_heading {
                font-size: 40px;
                padding: 30px;
            }
            .subtopics {
                font-size: 22px;
                padding: 12px 20px;
            }
            p, .def {
                font-size: 18px;
                padding: 15px;
                margin: 20px auto;
                max-width: 90%;
            }
            .fact {
                font-size: 28px;
                padding: 30px;
            }
            .tech_points {
                font-size: 18px;
                padding: 20px;
            }
            .tech_points li {
                padding-left: 30px;
            }
            .tech_points li::before {
                width: 8px;
                height: 8px;
            }
            .cavity-diagram {
                width: 250px;
                height: 250px;
            }
            .cavity-box, .cavity-face {
                width: 150px;
                height: 150px;
            }
            .front { transform: rotateY(0deg) translateZ(75px); }
            .back { transform: rotateY(180deg) translateZ(75px); }
            .right { transform: rotateY(90deg) translateZ(75px); }
            .left { transform: rotateY(-90deg) translateZ(75px); }
            .top { transform: rotateX(90deg) translateZ(75px); }
            .bottom { transform: rotateX(-90deg) translateZ(75px); }
            .cavity-face {
                font-size: 16px;
            }
            .face-label, .face-temp {
                font-size: 12px;
            }
            .radiation-particle {
                width: 4px;
                height: 4px;
            }
            .control-group {
                width: 120px;
                font-size: 16px;
            }
            .control-slider {
                width: 100%;
            }
            .current-value-display {
                font-size: 14px;
            }
            .result-display {
                font-size: 24px;
            }
            .app-grid {
                grid-template-columns: 1fr;
            }
            .app-icon {
                font-size: 36px;
            }
            .app-title {
                font-size: 20px;
            }
        }

        @media (max-width: 480px) {
            .main_heading {
                font-size: 32px;
                padding: 20px;
            }
            .subtopics {
                font-size: 18px;
                padding: 10px 15px;
            }
            p, .def {
                font-size: 16px;
                padding: 12px;
                margin: 15px auto;
            }
            .fact {
                font-size: 24px;
                padding: 25px;
            }
            .tech_points {
                font-size: 16px;
                padding: 15px;
            }
            .tech_points li {
                padding-left: 25px;
            }
            .tech_points li::before {
                width: 6px;
                height: 6px;
            }
            .cavity-diagram {
                width: 200px;
                height: 200px;
            }
            .cavity-box, .cavity-face {
                width: 120px;
                height: 120px;
            }
            .front { transform: rotateY(0deg) translateZ(60px); }
            .back { transform: rotateY(180deg) translateZ(60px); }
            .right { transform: rotateY(90deg) translateZ(60px); }
            .left { transform: rotateY(-90deg) translateZ(60px); }
            .top { transform: rotateX(90deg) translateZ(60px); }
            .bottom { transform: rotateX(-90deg) translateZ(60px); }
            .cavity-face {
                font-size: 14px;
            }
            .face-label, .face-temp {
                font-size: 10px;
            }
            .radiation-particle {
                width: 3px;
                height: 3px;
            }
            .control-group {
                width: 100px;
                font-size: 14px;
            }
            .control-slider {
                width: 100%;
            }
            .current-value-display {
                font-size: 12px;
            }
            .result-display {
                font-size: 20px;
            }
            .app-icon {
                font-size: 32px;
            }
            .app-title {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>

    <div class="main_heading">Radiation in Closed Cavities</div>

    <div class="def">
        <p>A **closed cavity** (or enclosure) in radiation heat transfer refers to a system of surfaces that completely enclose a space, such that all radiation leaving any surface within the enclosure is intercepted by another surface within that same enclosure.</p>
        <p>Analyzing radiation exchange in such systems is crucial for many engineering applications, from industrial furnaces to spacecraft thermal control.</p>
    </div>

    <div class="subtopics">Key Characteristics of Cavities</div>

    <div class="def">
        <ul class="tech_points">
            <li><b>Summation Rule:</b> For any surface $i$ in an enclosure, the sum of all view factors from surface $i$ to every other surface (including itself if concave) must equal unity: $\sum_{j=1}^{N} F_{i \to j} = 1$.</li>
            <li><b>No Radiation Escapes:</b> By definition, no radiation leaves the cavity. This simplifies the energy balance.</li>
            <li><b>Reradiating Surfaces:</b> Cavities often contain surfaces that are adiabatic (no net heat transfer to or from them). These are called reradiating surfaces, and their temperatures adjust until their absorbed radiation equals their emitted radiation.</li>
            <li><b>Blackbody Cavity:</b> A cavity with a small opening behaves like a blackbody, regardless of the material of its inner surfaces. This is because any radiation entering the cavity undergoes multiple reflections and is almost entirely absorbed.</li>
        </ul>
    </div>

    <div class="subtopics">Radiation Network for Cavities</div>

    <div class="def">
        <p>The **radiation network method** is particularly powerful for analyzing closed cavities. Each surface in the cavity is represented by a node in the network, and connections between nodes represent resistances to radiation flow.</p>
        <p>The network typically consists of:</p>
        <ul class="tech_points">
            <li><b>Surface Resistance:</b> $\frac{1 - \epsilon}{A \epsilon}$ for each gray surface, connecting its blackbody emissive power node ($E_b = \sigma T^4$) to its radiosity node ($J$).</li>
            <li><b>Space Resistance:</b> $\frac{1}{A_i F_{i \to j}}$ between the radiosity nodes ($J_i$ and $J_j$) of any two surfaces $i$ and $j$ that can see each other.</li>
            <li>For reradiating surfaces, their $E_b$ node is typically left floating (disconnected from a fixed potential), indicating that their temperature is unknown and will be determined by the energy balance.</li>
        </ul>
        <p>Solving the network (e.g., using Kirchhoff's laws for current and voltage) allows us to determine unknown temperatures, radiosities, and net heat transfer rates for each surface.</p>
    </div>

    <div class="subtopics">Interactive Cavity Visualization</div>

    <div class="cavity-visual-container">
        <h3>Heat Exchange in a Simple Cavity</h3>
        <div class="cavity-diagram">
            <div class="cavity-box" id="cavity-box">
                <div class="cavity-face front" id="face-front">
                    <span class="face-label">Front</span>
                    <span class="face-temp" id="temp-front-display">T: 400 K</span>
                </div>
                <div class="cavity-face back" id="face-back">
                    <span class="face-label">Back</span>
                    <span class="face-temp" id="temp-back-display">T: 300 K</span>
                </div>
                <div class="cavity-face right" id="face-right">
                    <span class="face-label">Right</span>
                    <span class="face-temp" id="temp-right-display">T: 350 K</span>
                </div>
                <div class="cavity-face left" id="face-left">
                    <span class="face-label">Left</span>
                    <span class="face-temp" id="temp-left-display">T: 350 K</span>
                </div>
                <div class="cavity-face top" id="face-top">
                    <span class="face-label">Top</span>
                    <span class="face-temp" id="temp-top-display">T: 250 K</span>
                </div>
                <div class="cavity-face bottom" id="face-bottom">
                    <span class="face-label">Bottom</span>
                    <span class="face-temp" id="temp-bottom-display">T: 500 K</span>
                </div>
            </div>
        </div>
        <div class="control-panel">
            <div class="control-group">
                <label for="temp-bottom-slider">T Bottom (K):</label>
                <input type="range" id="temp-bottom-slider" class="control-slider" min="100" max="1000" value="500">
                <span id="temp-bottom-value" class="current-value-display">500 K</span>
            </div>
            <div class="control-group">
                <label for="emissivity-bottom-slider">$\epsilon$ Bottom:</label>
                <input type="range" id="emissivity-bottom-slider" class="control-slider" min="0.1" max="1.0" step="0.05" value="0.9">
                <span id="emissivity-bottom-value" class="current-value-display">0.90</span>
            </div>
            <div class="control-group">
                <label for="temp-top-slider">T Top (K):</label>
                <input type="range" id="temp-top-slider" class="control-slider" min="100" max="1000" value="250">
                <span id="temp-top-value" class="current-value-display">250 K</span>
            </div>
            <div class="control-group">
                <label for="emissivity-top-slider">$\epsilon$ Top:</label>
                <input type="range" id="emissivity-top-slider" class="control-slider" min="0.1" max="1.0" step="0.05" value="0.7">
                <span id="emissivity-top-value" class="current-value-display">0.70</span>
            </div>
            <div class="control-group">
                <label for="temp-sides-slider">T Sides (K):</label>
                <input type="range" id="temp-sides-slider" class="control-slider" min="100" max="1000" value="350">
                <span id="temp-sides-value" class="current-value-display">350 K</span>
            </div>
            <div class="control-group">
                <label for="emissivity-sides-slider">$\epsilon$ Sides:</label>
                <input type="range" id="emissivity-sides-slider" class="control-slider" min="0.1" max="1.0" step="0.05" value="0.5">
                <span id="emissivity-sides-value" class="current-value-display">0.50</span>
            </div>
        </div>
        <div class="result-display" id="net-heat-transfer-display">
            Net Heat Transfer (Q<sub>Bottom</sub>): Calculating...
        </div>
        <p>Adjust the temperatures and emissivities of the cavity walls. Observe how the wall colors and glow change, and how the "radiation particles" animate to show the complex net heat flow within the cavity, particularly the net heat transfer from the bottom surface.</p>
    </div>

    <div class="fact">
        DID YOU KNOW? A well-designed cavity can achieve a very high apparent emissivity, even if its inner surfaces are not perfectly black. This principle is used in blackbody radiation sources for calibration!
    </div>

    <div class="subtopics">Implications and Applications</div>

    <div class="def">
        <ul class="tech_points">
            <li><b>Industrial Furnaces:</b> Analyzing heat transfer to workpieces placed inside high-temperature enclosures.</li>
            <li><b>Solar Cavity Receivers:</b> Designing receivers for concentrated solar power systems, where sunlight enters a cavity to heat a fluid.</li>
            <li><b>Spacecraft Thermal Design:</b> Modeling heat exchange within internal compartments and between components and the spacecraft's outer shell.</li>
            <li><b>Building Energy Simulation:</b> Calculating radiative heat transfer between interior surfaces of a room.</li>
            <li><b>Blackbody Calibration Sources:</b> Creating highly accurate blackbody radiation sources for calibrating infrared thermometers and sensors.</li>
        </ul>
    </div>

    <div class="app-grid">
        <div class="app-item">
            <div class="app-icon">üî•</div>
            <div class="app-title">Kilns & Ovens</div>
            <p>Ensuring uniform heating and energy efficiency in enclosed spaces.</p>
        </div>
        <div class="app-item">
            <div class="app-icon">‚òÄÔ∏è</div>
            <div class="app-title">Solar Cavity Receivers</div>
            <p>Maximizing solar energy absorption within a confined space.</p>
        </div>
        <div class="app-item">
            <div class="app-icon">üõ∞Ô∏è</div>
            <div class="app-title">Satellite Interiors</div>
            <p>Managing internal heat distribution and component temperatures.</p>
        </div>
        <div class="app-item">
            <div class="app-icon">üè°</div>
            <div class="app-title">Room Heat Transfer</div>
            <p>Analyzing radiative comfort and heat loss/gain in rooms.</p>
        </div>
        <div class="app-item">
            <div class="app-icon">üå°Ô∏è</div>
            <div class="app-title">IR Sensor Calibration</div>
            <p>Using blackbody cavities as precise radiation references.</p>
        </div>
        <div class="app-item">
            <div class="app-icon">üß™</div>
            <div class="app-title">Material Processing</div>
            <p>Controlling radiative environments for heat treatment of materials.</p>
        </div>
    </div>

    <script>
        // Stefan-Boltzmann constant
        const SIGMA = 5.670e-8; // W/(m^2 * K^4)

        // Get sliders
        const tempBottomSlider = document.getElementById('temp-bottom-slider');
        const emissivityBottomSlider = document.getElementById('emissivity-bottom-slider');
        const tempTopSlider = document.getElementById('temp-top-slider');
        const emissivityTopSlider = document.getElementById('emissivity-top-slider');
        const tempSidesSlider = document.getElementById('temp-sides-slider'); // For all 4 sides
        const emissivitySidesSlider = document.getElementById('emissivity-sides-slider'); // For all 4 sides

        // Get display elements
        const tempBottomDisplay = document.getElementById('temp-bottom-display');
        const emissivityBottomValue = document.getElementById('emissivity-bottom-value');
        const tempTopDisplay = document.getElementById('temp-top-display');
        const emissivityTopValue = document.getElementById('emissivity-top-value');
        const tempSidesDisplay = document.getElementById('temp-sides-display');
        const emissivitySidesValue = document.getElementById('emissivity-sides-value');
        const netHeatTransferDisplay = document.getElementById('net-heat-transfer-display');

        // Get cavity faces
        const faceFront = document.getElementById('face-front');
        const faceBack = document.getElementById('face-back');
        const faceRight = document.getElementById('face-right');
        const faceLeft = document.getElementById('face-left');
        const faceTop = document.getElementById('face-top');
        const faceBottom = document.getElementById('face-bottom');

        const cavityBox = document.getElementById('cavity-box');
        const cavityDiagram = document.querySelector('.cavity-diagram');

        // Particle animation variables
        let particles = [];
        const maxParticles = 50;
        const particleSize = 5; // pixels
        const cavitySize = 200; // pixels (width/height of faces)
        const halfCavitySize = cavitySize / 2;

        // Function to calculate net heat transfer for a specific surface (simplified network solution)
        // This is a highly simplified model for visualization, not a full matrix solution.
        // It assumes a square cavity and uses approximate view factors for simplicity.
        function calculateNetHeatTransfer() {
            const T_bottom = parseFloat(tempBottomSlider.value);
            const epsilon_bottom = parseFloat(emissivityBottomSlider.value);
            const T_top = parseFloat(tempTopSlider.value);
            const epsilon_top = parseFloat(emissivityTopSlider.value);
            const T_sides = parseFloat(tempSidesSlider.value);
            const epsilon_sides = parseFloat(emissivitySidesSlider.value);

            // Update display values
            tempBottomDisplay.textContent = `T: ${T_bottom} K`;
            emissivityBottomValue.textContent = epsilon_bottom.toFixed(2);
            tempTopDisplay.textContent = `T: ${T_top} K`;
            emissivityTopValue.textContent = epsilon_top.toFixed(2);
            tempSidesDisplay.textContent = `T: ${T_sides} K`;
            emissivitySidesValue.textContent = epsilon_sides.toFixed(2);

            // Update face colors and glow
            const faces = [faceFront, faceBack, faceRight, faceLeft, faceTop, faceBottom];
            const temps = {
                'bottom': T_bottom,
                'top': T_top,
                'front': T_sides,
                'back': T_sides,
                'right': T_sides,
                'left': T_sides
            };
            const emissivities = {
                'bottom': epsilon_bottom,
                'top': epsilon_top,
                'front': epsilon_sides,
                'back': epsilon_sides,
                'right': epsilon_sides,
                'left': epsilon_sides
            };

            const minTemp = 100;
            const maxTemp = 1000;

            faces.forEach(face => {
                const id = face.id.replace('face-', '');
                const temp = temps[id];
                const epsilon = emissivities[id];

                const normalizedTemp = (temp - minTemp) / (maxTemp - minTemp);
                const grayColor = Math.floor(255 * (1 - epsilon));
                face.style.backgroundColor = `rgba(${grayColor}, ${grayColor}, ${grayColor}, 0.8)`;

                const glowIntensity = 10 + normalizedTemp * 40;
                const glowColor = `rgba(255, ${Math.min(255, Math.floor(65 + normalizedTemp * 190))}, ${Math.min(255, Math.floor(108 + normalizedTemp * 147))}, 0.7)`;
                face.style.boxShadow = `0 0 ${glowIntensity}px ${glowColor}`;

                // Update text on faces
                face.querySelector('.face-temp').textContent = `T: ${temp} K`;
            });

            // --- Simplified Net Heat Transfer Calculation for Bottom Surface ---
            // This is a very simplified model. For a true network solution, you'd set up
            // a system of equations for J (radiosity) for each surface and solve them.
            // Here, we approximate the net heat transfer for the bottom surface (Q_bottom)
            // assuming it exchanges heat with an "average" of the other surfaces.

            const A_face = (cavitySize / 100) * (cavitySize / 100); // Area in m^2 (e.g., 200px = 2m, so 2x2 = 4m^2)
            const Eb_bottom = SIGMA * Math.pow(T_bottom, 4);
            const Eb_top = SIGMA * Math.pow(T_top, 4);
            const Eb_sides = SIGMA * Math.pow(T_sides, 4);

            // Approximate average temperature of surrounding surfaces for simplicity
            const T_avg_surroundings = (T_top + T_sides * 4) / 5; // Average of top and 4 sides
            const Eb_avg_surroundings = SIGMA * Math.pow(T_avg_surroundings, 4);

            // Very rough approximation of overall view factor from bottom to all others = 1
            // This is valid if the bottom surface "sees" only the other surfaces in the enclosure.
            // For a flat bottom in a cube, F_bottom_to_top = ~0.2, F_bottom_to_sides = ~0.8
            // We'll use a simplified total effective view factor for Q_bottom
            const F_bottom_to_others = 1.0; // Assuming it sees all other surfaces

            // Simplified net heat transfer (Q_bottom) based on average surrounding potential
            // This is NOT a rigorous network solution, but illustrates the concept.
            // Q_bottom = (Eb_bottom - J_bottom) / R_s_bottom
            // Q_bottom = (J_bottom - J_others) / R_space_bottom_to_others
            // For a simple visualization, we can use an effective overall exchange:
            let Q_bottom_net = A_face * F_bottom_to_others * SIGMA * (T_bottom**4 - T_avg_surroundings**4);

            // Account for emissivity of the bottom surface
            // For gray surfaces, Q_net = A * F_eff * (Eb1 - Eb2) where F_eff is complex.
            // A simpler approach for visualization: use a modified Stefan-Boltzmann for gray surfaces
            // Q_net = A * F_eff * (J_bottom - J_avg_surroundings)
            // Instead, let's use a very rough analogy:
            // Q_bottom_net = (Eb_bottom - Eb_avg_surroundings) / (R_s_bottom + R_s_avg_surroundings + R_space_effective)
            // This requires solving the network, which is beyond simple JS.

            // Let's revert to a more conceptual Q_net for visualization:
            // The net heat transfer from the bottom will be influenced by its own emissivity
            // and the effective temperature of what it sees.
            // For a simple visual, we can show the difference in emissive power, scaled by emissivity.
            Q_bottom_net = A_face * epsilon_bottom * SIGMA * (T_bottom**4 - T_avg_surroundings**4);


            netHeatTransferDisplay.textContent = `Net Heat Transfer (Q_Bottom): ${Q_bottom_net.toFixed(2)} W`;

            // Update particle animation
            updateParticles(T_bottom, T_top, T_sides, Q_bottom_net);
        }

        // Function to manage particle animation
        function updateParticles(T_bottom, T_top, T_sides, Q_bottom_net) {
            // Clear existing particles
            const existingParticles = document.querySelectorAll('.radiation-particle');
            existingParticles.forEach(p => p.remove());
            particles = [];

            // Determine relative temperatures to simulate flow direction
            const temps = {
                'bottom': T_bottom,
                'top': T_top,
                'sides': T_sides
            };

            const sortedTemps = Object.entries(temps).sort(([, a], [, b]) => b - a); // Sort from hottest to coldest

            const hottestSurface = sortedTemps[0][0];
            const coldestSurface = sortedTemps[sortedTemps.length - 1][0];

            let particleCount = Math.min(maxParticles, Math.ceil(Math.abs(Q_bottom_net) * 10)); // Scale by net heat for bottom

            // Create particles
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'radiation-particle';
                cavityBox.appendChild(particle); // Append to cavity-box for 3D transform inheritance
                particles.push(particle);

                let startX, startY, startZ, endX, endY, endZ;
                let duration = 2 + Math.random() * 1; // Randomize duration

                // Determine start and end points based on temperature differences
                // Simplified: particles originate from hotter surfaces and move towards colder ones.
                // For a full network, particles would move between J nodes.

                const randX = (Math.random() - 0.5) * cavitySize * 0.8;
                const randY = (Math.random() - 0.5) * cavitySize * 0.8;

                // Example: Flow from hottest to coldest
                if (hottestSurface === 'bottom' && coldestSurface === 'top') {
                    startX = randX; startY = randY; startZ = -halfCavitySize; // From bottom face
                    endX = (Math.random() - 0.5) * cavitySize * 0.8;
                    endY = (Math.random() - 0.5) * cavitySize * 0.8;
                    endZ = halfCavitySize; // To top face
                } else if (hottestSurface === 'top' && coldestSurface === 'bottom') {
                    startX = randX; startY = randY; startZ = halfCavitySize; // From top face
                    endX = (Math.random() - 0.5) * cavitySize * 0.8;
                    endY = (Math.random() - 0.5) * cavitySize * 0.8;
                    endZ = -halfCavitySize; // To bottom face
                } else {
                    // More complex flow, pick random hot source and cold destination
                    const sourceFaceId = sortedTemps[0][0];
                    const destFaceId = sortedTemps[sortedTemps.length - 1][0];

                    // Map face IDs to conceptual start/end Z positions
                    const getZ = (faceId) => {
                        if (faceId === 'bottom') return -halfCavitySize;
                        if (faceId === 'top') return halfCavitySize;
                        return (Math.random() - 0.5) * cavitySize * 0.8; // For sides, random Z
                    };

                    const getX = (faceId) => {
                        if (faceId === 'left') return -halfCavitySize;
                        if (faceId === 'right') return halfCavitySize;
                        return (Math.random() - 0.5) * cavitySize * 0.8; // For top/bottom/front/back, random X
                    };

                    const getY = (faceId) => {
                        if (faceId === 'front') return -halfCavitySize;
                        if (faceId === 'back') return halfCavitySize;
                        return (Math.random() - 0.5) * cavitySize * 0.8; // For top/bottom/left/right, random Y
                    };

                    startX = getX(sourceFaceId);
                    startY = getY(sourceFaceId);
                    startZ = getZ(sourceFaceId);

                    endX = getX(destFaceId);
                    endY = getY(destFaceId);
                    endZ = getZ(destFaceId);

                    // If source and destination are the same (e.g., all temps equal), make particles move randomly
                    if (sourceFaceId === destFaceId) {
                        startX = (Math.random() - 0.5) * cavitySize * 0.8;
                        startY = (Math.random() - 0.5) * cavitySize * 0.8;
                        startZ = (Math.random() - 0.5) * cavitySize * 0.8;
                        endX = (Math.random() - 0.5) * cavitySize * 0.8;
                        endY = (Math.random() - 0.5) * cavitySize * 0.8;
                        endZ = (Math.random() - 0.5) * cavitySize * 0.8;
                    }
                }

                // Center particles around the cavity box origin
                particle.style.setProperty('--start-x', `${startX}px`);
                particle.style.setProperty('--start-y', `${startY}px`);
                particle.style.setProperty('--start-z', `${startZ}px`);
                particle.style.setProperty('--end-x', `${endX}px`);
                particle.style.setProperty('--end-y', `${endY}px`);
                particle.style.setProperty('--end-z', `${endZ}px`);
                particle.style.animationDuration = `${duration}s`;
                particle.style.animationDelay = `${Math.random() * duration}s`;
            }
        }

        // Add event listeners to all sliders
        tempBottomSlider.addEventListener('input', calculateNetHeatTransfer);
        emissivityBottomSlider.addEventListener('input', calculateNetHeatTransfer);
        tempTopSlider.addEventListener('input', calculateNetHeatTransfer);
        emissivityTopSlider.addEventListener('input', calculateNetHeatTransfer);
        tempSidesSlider.addEventListener('input', calculateNetHeatTransfer);
        emissivitySidesSlider.addEventListener('input', calculateNetHeatTransfer);

        // Initial update on page load
        document.addEventListener('DOMContentLoaded', calculateNetHeatTransfer);

        // Optional: Add mouse interaction for rotating the cavity
        let isDragging = false;
        let startX, startY;
        let currentRotateX = 20;
        let currentRotateY = -30;

        cavityDiagram.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            cavityDiagram.style.cursor = 'grabbing';
        });

        cavityDiagram.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;

            // Sensitivity adjustment
            currentRotateY += dx * 0.5;
            currentRotateX -= dy * 0.5;

            cavityBox.style.transform = `rotateX(${currentRotateX}deg) rotateY(${currentRotateY}deg)`;
            startX = e.clientX;
            startY = e.clientY;
        });

        cavityDiagram.addEventListener('mouseup', () => {
            isDragging = false;
            cavityDiagram.style.cursor = 'grab';
        });

        cavityDiagram.addEventListener('mouseleave', () => {
            isDragging = false;
            cavityDiagram.style.cursor = 'grab';
        });

        // Touch events for mobile
        cavityDiagram.addEventListener('touchstart', (e) => {
            isDragging = true;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            cavityDiagram.style.cursor = 'grabbing';
        });

        cavityDiagram.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const dx = e.touches[0].clientX - startX;
            const dy = e.touches[0].clientY - startY;

            currentRotateY += dx * 0.5;
            currentRotateX -= dy * 0.5;

            cavityBox.style.transform = `rotateX(${currentRotateX}deg) rotateY(${currentRotateY}deg)`;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        });

        cavityDiagram.addEventListener('touchend', () => {
            isDragging = false;
            cavityDiagram.style.cursor = 'grab';
        });
    </script>

</body>
</html>
