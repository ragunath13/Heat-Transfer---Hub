<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Evaporative Condenser</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif; /* Using Inter font */
        }
        canvas {
            display: block;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px; /* Rounded corners */
            max-width: 600px;
            text-align: center;
            transition: all 0.5s ease;
            z-index: 100;
            border: 1px solid #ff9800; /* Orange border */
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.2); /* Orange shadow */
        }
        .info-panel h3 {
            margin-top: 0;
            color: #ff9800; /* Orange title */
            font-size: 22px;
        }
        .info-panel p {
            margin-bottom: 0;
            font-size: 16px;
            line-height: 1.5;
        }
        #title {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            z-index: 100;
            border-radius: 8px; /* Rounded corners */
        }
        #controls {
            position: absolute;
            top: 70px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid #ff9800; /* Orange border */
            padding: 8px 12px;
            border-radius: 4px; /* Rounded corners */
            cursor: pointer;
            min-width: 180px; /* Increased width for better text display */
            text-align: left;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            box-shadow: 0 2px 5px rgba(255, 152, 0, 0.1); /* Subtle shadow */
        }
        button:hover {
            background-color: rgba(255, 152, 0, 0.2); /* Lighter orange on hover */
            border-color: #ffcc80; /* Lighter border on hover */
        }
        .component-button {
            display: flex;
            align-items: center;
        }
        .component-button .color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            display: inline-block;
            border: 1px solid rgba(255, 255, 255, 0.3); /* Small border for visibility */
        }
    </style>
</head>
<body>
    <div id="title">Evaporative Condenser - Click on any component</div>
    <div id="controls">
        <button id="reset-view">Show Full Assembly</button>
        <button id="toggle-casing"><span class="color-indicator" style="background-color: #757575;"></span>Toggle Casing Transparency</button>
        <button id="section-view">Section View</button>
        <div style="margin-top: 10px; color: white; font-size: 14px;">Component Quick View:</div>
        <button id="view-casing"><span class="color-indicator" style="background-color: #757575;"></span>View Casing</button>
        <button id="view-coil-bundle"><span class="color-indicator" style="background-color: #03a9f4;"></span>View Coil Bundle</button>
        <button id="view-spray-system"><span class="color-indicator" style="background-color: #2196f3;"></span>View Spray System</button>
        <button id="view-sump"><span class="color-indicator" style="background-color: #4fc3f7;"></span>View Sump/Basin</button>
        <button id="view-fans"><span class="color-indicator" style="background-color: #e0e0e0;"></span>View Fans</button>
        <button id="view-eliminators"><span class="color-indicator" style="background-color: #bdbdbd;"></span>View Eliminators</button>
        <button id="view-steam-inlet"><span class="color-indicator" style="background-color: #ffeb3b;"></span>View Steam Inlet</button>
        <button id="view-condensate-outlet"><span class="color-indicator" style="background-color: #8bc34a;"></span>View Condensate Outlet</button>
    </div>
    <div id="info-panel" class="info-panel" style="display: none;">
        <h3 id="component-title">Component</h3>
        <p id="component-description">Description will appear here</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/curves/CatmullRomCurve3.js"></script>
    <script>
        // Main variables
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Black background

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 50); // Initial camera position, elevated
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        document.body.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth camera movement
        controls.dampingFactor = 0.05;
        controls.target.set(0, 5, 0); // Point camera towards the center
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Soft ambient light
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Main light source
        directionalLight.position.set(10, 30, 20);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024; // default
        directionalLight.shadow.mapSize.height = 1024; // default
        directionalLight.shadow.camera.near = 0.5; // default
        directionalLight.shadow.camera.far = 100; // default
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);
        
        const backLight = new THREE.DirectionalLight(0xffffff, 0.3); // Secondary light
        backLight.position.set(-10, -30, -20);
        scene.add(backLight);
        
        // Interaction tools
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Animation variables
        let animationId = null;
        let targetPosition = null;
        let targetLookAt = null;
        let isAnimating = false;
        
        // Section view
        let isSectionView = false;
        // Section plane for cutting through the model (initially cutting along XZ plane)
        const sectionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); 
        const sectionHelper = new THREE.PlaneHelper(sectionPlane, 20, 0xff0000); // Red helper plane
        sectionHelper.visible = false;
        scene.add(sectionHelper);
        renderer.localClippingEnabled = false; // Disable clipping by default

        // Component storage
        const components = {
            casing: null,
            coilBundle: null,
            spraySystem: null,
            sump: null,
            fans: null,
            eliminators: null,
            steamInlet: null,
            condensateOutlet: null,
            fluidFlowSteam: null,
            fluidFlowCondensate: null,
            fluidFlowCoolingWater: null,
            fluidFlowAir: null,
            fullAssembly: null
        };
        
        // Component information (descriptions, colors, etc.)
        const componentInfo = {
            'casing': {
                title: 'Condenser Casing/Structure',
                description: 'The main enclosure of the evaporative condenser, typically made of galvanized steel or stainless steel, housing all internal components.',
                color: 0x757575, // Medium Grey
                internal: false
            },
            'coilBundle': {
                title: 'Coil Bundle',
                description: 'A bank of tubes (coils) through which the hot steam or refrigerant flows. Cooling water is sprayed over these coils, and air is drawn across them to facilitate heat transfer and condensation.',
                color: 0x03a9f4, // Light Blue
                internal: true
            },
            'spraySystem': {
                title: 'Spray System / Water Distribution',
                description: 'Consists of spray nozzles or distribution pans that evenly distribute cooling water over the coil bundle, maximizing the evaporative cooling effect.',
                color: 0x2196f3, // Blue
                internal: true
            },
            'sump': {
                title: 'Sump / Water Basin',
                description: 'The basin at the bottom of the condenser that collects the cooled water, which is then recirculated by a pump back to the spray system.',
                color: 0x4fc3f7, // Light Blue
                internal: false
            },
            'fans': {
                title: 'Fans (Axial or Centrifugal)',
                description: 'Large fans that draw or push air through the condenser, facilitating the evaporation of cooling water and removal of latent heat from the steam/refrigerant.',
                color: 0xe0e0e0, // Light Grey
                internal: false
            },
            'eliminators': {
                title: 'Drift Eliminators',
                description: 'Baffles or louvers positioned above the spray section that remove entrained water droplets from the air stream, preventing water loss and environmental impact.',
                color: 0xbdbdbd, // Light Grey
                internal: true
            },
            'steamInlet': {
                title: 'Steam/Refrigerant Inlet',
                description: 'The connection point where the hot steam or refrigerant vapor enters the coil bundle to be condensed.',
                color: 0xffeb3b, // Yellow
                internal: false
            },
            'condensateOutlet': {
                title: 'Condensate/Liquid Outlet',
                description: 'The connection point where the condensed steam (liquid water) or refrigerant liquid exits the coil bundle.',
                color: 0x8bc34a, // Light Green
                internal: false
            }
        };

        // Global constants for condenser dimensions
        const casingWidth = 30;
        const casingLength = 20;
        const casingHeight = 35;
        const casingThickness = 0.5;

        const coilBundleWidth = casingWidth * 0.7;
        const coilBundleLength = casingLength * 0.7;
        const coilBundleHeight = 10;
        const tubeRadius = 0.3;
        const numCoilRows = 8;
        const numCoilCols = 8;
        const coilSpacing = 1.0;

        const sprayPipeRadius = 0.5;
        const numSprayPipes = 3;
        const numSprayNozzlesPerPipe = 5;
        const nozzleConeHeight = 1;
        const nozzleConeRadius = 0.5;

        const sumpHeight = 5;
        const fanDiameter = 8;
        const fanHeight = 2;
        const numFans = 2; // Side-by-side on top

        const eliminatorHeight = 3;
        const eliminatorThickness = 0.2;
        const numEliminatorBlades = 10;

        const inletOutletRadius = 1.5;
        const inletOutletLength = 4;

        // Global constants for fluid particles
        const particleSizeSteam = 0.4;
        const particleSizeCondensate = 0.3;
        const particleSizeCoolingWater = 0.35;
        const particleSizeAir = 0.5;


        // Create all components of the evaporative condenser
        function createComponents() {
            // Casing
            const casingMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.casing.color,
                metalness: 0.6,
                roughness: 0.4,
                transparent: true,
                opacity: 0.2, // Initially transparent
                side: THREE.DoubleSide
            });
            components.casing = new THREE.Mesh(
                new THREE.BoxGeometry(casingWidth, casingHeight, casingLength),
                casingMaterial
            );
            components.casing.position.y = sumpHeight / 2; // Position above sump
            components.casing.userData = { type: 'casing' };

            // Sump / Water Basin
            const sumpMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.sump.color,
                metalness: 0.4,
                roughness: 0.6,
                transparent: true,
                opacity: 0.8, // More opaque to show water
                side: THREE.DoubleSide
            });
            components.sump = new THREE.Mesh(
                new THREE.BoxGeometry(casingWidth, sumpHeight, casingLength),
                sumpMaterial
            );
            components.sump.position.y = -casingHeight / 2 - sumpHeight / 2;
            components.sump.userData = { type: 'sump' };

            // Coil Bundle
            components.coilBundle = new THREE.Group();
            const coilMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.coilBundle.color,
                metalness: 0.7,
                roughness: 0.3
            });
            const coilBaseY = components.sump.position.y + sumpHeight / 2 + coilBundleHeight / 2 + 2; // Above sump

            const offsetX = (numCoilRows - 1) * coilSpacing / 2;
            const offsetZ = (numCoilCols - 1) * coilSpacing / 2;

            for (let i = 0; i < numCoilRows; i++) {
                for (let j = 0; j < numCoilCols; j++) {
                    const xPos = (i * coilSpacing) - offsetX;
                    const zPos = (j * coilSpacing) - offsetZ;

                    const coil = new THREE.Mesh(
                        new THREE.CylinderGeometry(tubeRadius, tubeRadius, coilBundleHeight, 16),
                        coilMaterial
                    );
                    coil.position.set(xPos, coilBaseY, zPos);
                    coil.userData = { type: 'coilBundle' };
                    components.coilBundle.add(coil);
                }
            }
            components.coilBundle.userData = { type: 'coilBundle' };

            // Spray System
            components.spraySystem = new THREE.Group();
            const sprayPipeMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.spraySystem.color,
                metalness: 0.6,
                roughness: 0.4
            });
            const sprayNozzleMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.spraySystem.color,
                metalness: 0.7,
                roughness: 0.3
            });

            const sprayPipeY = coilBaseY + coilBundleHeight / 2 + 2; // Above coil bundle
            const sprayPipeSpacing = coilBundleWidth / (numSprayPipes + 1);

            for (let i = 0; i < numSprayPipes; i++) {
                const pipeX = (i * sprayPipeSpacing) - (numSprayPipes - 1) * sprayPipeSpacing / 2;
                const pipe = new THREE.Mesh(
                    new THREE.CylinderGeometry(sprayPipeRadius, sprayPipeRadius, coilBundleLength * 0.8, 16),
                    sprayPipeMaterial
                );
                pipe.rotation.x = Math.PI / 2; // Horizontal along Z
                pipe.position.set(pipeX, sprayPipeY, 0);
                components.spraySystem.add(pipe);

                // Nozzles on pipe
                const nozzleSpacing = (coilBundleLength * 0.8) / (numSprayNozzlesPerPipe + 1);
                for (let j = 0; j < numSprayNozzlesPerPipe; j++) {
                    const nozzleZ = (j * nozzleSpacing) - (numSprayNozzlesPerPipe - 1) * nozzleSpacing / 2;
                    const nozzle = new THREE.Mesh(
                        new THREE.ConeGeometry(nozzleConeRadius, nozzleConeHeight, 16),
                        sprayNozzleMaterial
                    );
                    nozzle.position.set(pipeX, sprayPipeY - nozzleConeHeight / 2, nozzleZ);
                    components.spraySystem.add(nozzle);
                }
            }
            components.spraySystem.userData = { type: 'spraySystem' };


            // Fans
            components.fans = new THREE.Group();
            const fanHousingMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.fans.color,
                metalness: 0.7,
                roughness: 0.3
            });
            const fanBladeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x424242, // Dark grey for blades
                metalness: 0.8,
                roughness: 0.2
            });

            const fanY = casingHeight / 2 + sumpHeight / 2 + fanHeight / 2; // Top of casing
            const fanSpacing = casingWidth / (numFans + 1);

            for (let i = 0; i < numFans; i++) {
                const fanX = (i * fanSpacing) - (numFans - 1) * fanSpacing / 2;
                const fanHousing = new THREE.Mesh(
                    new THREE.CylinderGeometry(fanDiameter / 2, fanDiameter / 2, fanHeight, 32),
                    fanHousingMaterial
                );
                fanHousing.position.set(fanX, fanY, 0);
                components.fans.add(fanHousing);

                // Fan blades (simplified)
                const bladeGeo = new THREE.BoxGeometry(fanDiameter * 0.4, 0.2, fanDiameter * 0.1);
                const blade1 = new THREE.Mesh(bladeGeo, fanBladeMaterial);
                blade1.rotation.y = Math.PI / 4;
                fanHousing.add(blade1);
                const blade2 = blade1.clone();
                blade2.rotation.y = -Math.PI / 4;
                fanHousing.add(blade2);
            }
            components.fans.userData = { type: 'fans' };

            // Drift Eliminators
            components.eliminators = new THREE.Group();
            const eliminatorMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.eliminators.color,
                metalness: 0.3,
                roughness: 0.7,
                transparent: true,
                opacity: 0.6
            });
            const eliminatorY = sprayPipeY + sprayPipeRadius + eliminatorHeight / 2 + 1; // Above spray system

            for (let i = 0; i < numEliminatorBlades; i++) {
                const blade = new THREE.Mesh(
                    new THREE.BoxGeometry(casingWidth * 0.8, eliminatorHeight, eliminatorThickness),
                    eliminatorMaterial
                );
                blade.rotation.y = Math.PI / 4; // Angled blades
                blade.position.set(0, eliminatorY, (i * (eliminatorThickness * 2)) - (numEliminatorBlades - 1) * (eliminatorThickness * 2) / 2);
                components.eliminators.add(blade);
            }
            components.eliminators.userData = { type: 'eliminators' };


            // Steam Inlet
            const steamInletMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.steamInlet.color,
                metalness: 0.5,
                roughness: 0.5
            });
            components.steamInlet = new THREE.Mesh(
                new THREE.CylinderGeometry(inletOutletRadius, inletOutletRadius, inletOutletLength, 32),
                steamInletMaterial
            );
            components.steamInlet.rotation.z = Math.PI / 2; // Horizontal
            components.steamInlet.position.set(-casingWidth / 2 - inletOutletLength / 2, coilBaseY + coilBundleHeight / 4, 0); // Side of coil bundle
            components.steamInlet.userData = { type: 'steamInlet' };

            // Condensate Outlet
            const condensateOutletMaterial = new THREE.MeshPhysicalMaterial({
                color: componentInfo.condensateOutlet.color,
                metalness: 0.7,
                roughness: 0.3
            });
            components.condensateOutlet = new THREE.Mesh(
                new THREE.CylinderGeometry(inletOutletRadius * 0.8, inletOutletRadius * 0.8, inletOutletLength, 32),
                condensateOutletMaterial
            );
            components.condensateOutlet.rotation.z = Math.PI / 2; // Horizontal
            components.condensateOutlet.position.set(casingWidth / 2 + inletOutletLength / 2, coilBaseY - coilBundleHeight / 4, 0); // Opposite side, lower
            components.condensateOutlet.userData = { type: 'condensateOutlet' };


            // Fluid Flow Animation
            components.fluidFlowSteam = new THREE.Group();
            components.fluidFlowCondensate = new THREE.Group();
            components.fluidFlowCoolingWater = new THREE.Group();
            components.fluidFlowAir = new THREE.Group();

            const steamColor = 0xffffff; // White for steam
            const condensateColor = 0x8bc34a; // Light Green for condensate
            const coolingWaterColor = 0x2196f3; // Blue for cooling water
            const airColor = 0xadd8e6; // Light Blue for air

            function createFluidParticles(color, numParticles, size) {
                const positions = new Float32Array(numParticles * 3);
                const particles = new THREE.BufferAttribute(positions, 3);
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', particles);

                const material = new THREE.PointsMaterial({
                    color: color,
                    size: size,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.7,
                    sizeAttenuation: true
                });

                const points = new THREE.Points(geometry, material);
                points.userData.progress = new Array(numParticles).fill(0).map(() => Math.random()); // Random initial progress
                return points;
            }

            // Steam Flow (through coil bundle, condensing)
            const steamParticles = createFluidParticles(steamColor, 200, particleSizeSteam);
            steamParticles.userData.paths = [];
            
            // Path from steam inlet, through a coil, to condensate outlet
            const sampleCoil = components.coilBundle.children[0]; // First coil
            const steamPathPoints = [
                components.steamInlet.position.clone().add(new THREE.Vector3(inletOutletLength / 2, 0, 0)),
                sampleCoil.position.clone().add(new THREE.Vector3(-coilBundleHeight / 2, 0, 0)),
                sampleCoil.position.clone().add(new THREE.Vector3(coilBundleHeight / 2, 0, 0)),
                components.condensateOutlet.position.clone().add(new THREE.Vector3(-inletOutletLength / 2, 0, 0))
            ];
            steamParticles.userData.paths.push(new THREE.CatmullRomCurve3(steamPathPoints));
            components.fluidFlowSteam.add(steamParticles);

            // Condensate Flow (from coil outlet)
            const condensateParticles = createFluidParticles(condensateColor, 80, particleSizeCondensate);
            condensateParticles.userData.paths = [];
            const condensatePathPoints = [
                components.condensateOutlet.position.clone().add(new THREE.Vector3(inletOutletLength / 2, 0, 0)),
                components.condensateOutlet.position.clone().add(new THREE.Vector3(inletOutletLength, 0, 0))
            ];
            condensateParticles.userData.paths.push(new THREE.CatmullRomCurve3(condensatePathPoints));
            components.fluidFlowCondensate.add(condensateParticles);

            // Cooling Water Flow (from sump, sprayed over coils, falling back to sump)
            const coolingWaterParticles = createFluidParticles(coolingWaterColor, 300, particleSizeCoolingWater);
            coolingWaterParticles.userData.paths = [];
            
            // Path from sump, up to spray, then down
            const waterPumpPoint = components.sump.position.clone().add(new THREE.Vector3(casingWidth / 4, sumpHeight / 2, 0));
            const sprayPoint = components.spraySystem.children[0].position.clone().add(new THREE.Vector3(0, nozzleConeHeight / 2, 0));
            const returnToSumpPoint = components.sump.position.clone().add(new THREE.Vector3(-casingWidth / 4, sumpHeight / 2, 0));

            coolingWaterParticles.userData.paths.push(new THREE.CatmullRomCurve3([
                waterPumpPoint,
                sprayPoint,
                new THREE.Vector3(sprayPoint.x, sprayPoint.y - coilBundleHeight - 5, sprayPoint.z), // Falling over coils
                returnToSumpPoint
            ]));
            components.fluidFlowCoolingWater.add(coolingWaterParticles);

            // Air Flow (from bottom/sides, through coils, out top)
            const airParticles = createFluidParticles(airColor, 250, particleSizeAir);
            components.fluidFlowAir.add(airParticles);


            components.fluidFlowSteam.visible = false;
            components.fluidFlowCondensate.visible = false;
            components.fluidFlowCoolingWater.visible = false;
            components.fluidFlowAir.visible = false;
            scene.add(components.fluidFlowSteam);
            scene.add(components.fluidFlowCondensate);
            scene.add(components.fluidFlowCoolingWater);
            scene.add(components.fluidFlowAir);


            // Full assembly
            components.fullAssembly = new THREE.Group();
            components.fullAssembly.add(components.casing);
            components.fullAssembly.add(components.coilBundle);
            components.fullAssembly.add(components.spraySystem);
            components.fullAssembly.add(components.sump);
            components.fullAssembly.add(components.fans);
            components.fullAssembly.add(components.eliminators);
            components.fullAssembly.add(components.steamInlet);
            components.fullAssembly.add(components.condensateOutlet);
            
            scene.add(components.fullAssembly);
        }

        // Initialize components
        createComponents();

        // Show only specific component(s)
        function showOnly(componentType) {
            // Hide all components first
            Object.values(components).forEach(comp => {
                if (comp && comp !== components.fullAssembly && comp.isObject3D && comp.isMesh === undefined) { 
                     // If it's a group, iterate its children
                    comp.children.forEach(child => child.visible = false);
                } else if (comp && comp !== components.fullAssembly && comp.isMesh) {
                    comp.visible = false;
                }
            });
            
            // Hide fluid animations by default when changing views
            components.fluidFlowSteam.visible = false;
            components.fluidFlowCondensate.visible = false;
            components.fluidFlowCoolingWater.visible = false;
            components.fluidFlowAir.visible = false;

            // Make casing transparent for internal views
            if (components.casing) {
                components.casing.material.opacity = 0.2;
                components.casing.material.needsUpdate = true;
                document.getElementById('toggle-casing').textContent = 'Make Casing Opaque';
            }

            // Show the requested component(s) and relevant context
            if (componentType === 'casing') {
                components.casing.visible = true;
                components.casing.material.opacity = 0.7; // Make casing more visible for its own view
                document.getElementById('toggle-casing').textContent = 'Make Casing Transparent';
            } else if (componentType === 'coilBundle') {
                components.coilBundle.children.forEach(child => child.visible = true);
                components.casing.visible = true; // Context
                components.spraySystem.children.forEach(child => child.visible = true); // Context
                components.sump.visible = true; // Context
                components.steamInlet.visible = true; // Context
                components.condensateOutlet.visible = true; // Context
                components.fluidFlowSteam.visible = true;
                components.fluidFlowCondensate.visible = true;
                components.fluidFlowCoolingWater.visible = true;
                components.fluidFlowAir.visible = true;
            } else if (componentType === 'spraySystem') {
                components.spraySystem.children.forEach(child => child.visible = true);
                components.casing.visible = true; // Context
                components.coilBundle.children.forEach(child => child.visible = true); // Context
                components.sump.visible = true; // Context
                components.fluidFlowCoolingWater.visible = true;
            } else if (componentType === 'sump') {
                components.sump.visible = true;
                components.casing.visible = true; // Context
                components.fluidFlowCoolingWater.visible = true;
            } else if (componentType === 'fans') {
                components.fans.children.forEach(child => child.visible = true);
                components.casing.visible = true; // Context
                components.eliminators.children.forEach(child => child.visible = true); // Context
                components.fluidFlowAir.visible = true;
            } else if (componentType === 'eliminators') {
                components.eliminators.children.forEach(child => child.visible = true);
                components.casing.visible = true; // Context
                components.fans.children.forEach(child => child.visible = true); // Context
                components.fluidFlowAir.visible = true;
                components.fluidFlowCoolingWater.visible = true; // To show water droplets being removed
            } else if (componentType === 'steamInlet') {
                components.steamInlet.visible = true;
                components.casing.visible = true; // Context
                components.coilBundle.children.forEach(child => child.visible = true); // Context
                components.fluidFlowSteam.visible = true;
            } else if (componentType === 'condensateOutlet') {
                components.condensateOutlet.visible = true;
                components.casing.visible = true; // Context
                components.coilBundle.children.forEach(child => child.visible = true); // Context
                components.fluidFlowCondensate.visible = true;
            } else if (componentType === 'full') {
                Object.values(components).forEach(comp => {
                    if (comp && comp !== components.fullAssembly && comp.isObject3D && comp.isMesh === undefined) { 
                        comp.children.forEach(child => child.visible = true);
                    } else if (comp && comp.isMesh) {
                        comp.visible = true;
                    }
                });
                components.casing.material.opacity = 0.2; // Keep casing transparent in full view
                document.getElementById('toggle-casing').textContent = 'Make Casing Opaque';

                // Show all fluid animations in full view by default
                components.fluidFlowSteam.visible = true;
                components.fluidFlowCondensate.visible = true;
                components.fluidFlowCoolingWater.visible = true;
                components.fluidFlowAir.visible = true;
            }
            
            // Update info panel if showing single component
            if (componentType !== 'full' && componentInfo[componentType]) {
                document.getElementById('component-title').textContent = componentInfo[componentType].title;
                document.getElementById('component-description').textContent = componentInfo[componentType].description;
                document.getElementById('info-panel').style.display = 'block';
            } else {
                document.getElementById('info-panel').style.display = 'none';
            }
            
            // Focus camera on the shown component(s)
            let targetObject;
            if (componentType === 'casing') targetObject = components.casing;
            else if (componentType === 'coilBundle') targetObject = components.coilBundle;
            else if (componentType === 'spraySystem') targetObject = components.spraySystem;
            else if (componentType === 'sump') targetObject = components.sump;
            else if (componentType === 'fans') targetObject = components.fans;
            else if (componentType === 'eliminators') targetObject = components.eliminators;
            else if (componentType === 'steamInlet') targetObject = components.steamInlet;
            else if (componentType === 'condensateOutlet') targetObject = components.condensateOutlet;
            else targetObject = components.fullAssembly;
            
            animateCameraToComponent(targetObject);
        }

        // Camera animation to focus on object
        function animateCameraToComponent(object) {
            if (isAnimating) return;
            
            isAnimating = true;
            controls.enabled = false; // Disable orbit controls during animation
            
            const boundingBox = new THREE.Box3().setFromObject(object);
            const size = boundingBox.getSize(new THREE.Vector3());
            const center = boundingBox.getCenter(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 1.8; // Adjust multiplier for desired zoom level
            
            // Calculate target position for camera
            const currentCameraPosition = camera.position.clone();
            const currentLookAt = controls.target.clone();

            // Determine a direction from the object's center to place the camera
            // Default to looking from front-right-top if object is at origin
            let direction = new THREE.Vector3().subVectors(currentCameraPosition, center).normalize();
            if (direction.length() === 0) direction.set(0.5, 0.5, 1).normalize(); // Fallback if camera is at center

            targetPosition = new THREE.Vector3().copy(center).add(direction.multiplyScalar(distance));
            targetLookAt = center.clone();
            
            animateCamera();
        }

        function animateCamera() {
            if (!targetPosition || !targetLookAt) return;
            
            const moveSpeed = 0.05; // Slower for smoother transition
            const lookSpeed = 0.05;
            
            camera.position.lerp(targetPosition, moveSpeed);
            controls.target.lerp(targetLookAt, lookSpeed);
            
            const positionDiff = camera.position.distanceTo(targetPosition);
            const lookDiff = controls.target.distanceTo(targetLookAt);
            
            if (positionDiff < 0.1 && lookDiff < 0.1) { // Threshold for animation end
                camera.position.copy(targetPosition);
                controls.target.copy(targetLookAt);
                isAnimating = false;
                controls.enabled = true; // Re-enable orbit controls
                return;
            }
            
            animationId = requestAnimationFrame(animateCamera);
        }

        // Toggle casing transparency
        function toggleCasingTransparency() {
            if (components.casing.material.opacity < 1) {
                components.casing.material.opacity = 0.7; // Make opaque
                document.getElementById('toggle-casing').textContent = 'Make Casing Transparent';
            } else {
                components.casing.material.opacity = 0.2; // Make transparent
                document.getElementById('toggle-casing').textContent = 'Make Casing Opaque';
            }
            components.casing.material.needsUpdate = true;
        }

        // Toggle section view
        function toggleSectionView() {
            isSectionView = !isSectionView;
            renderer.localClippingEnabled = isSectionView;
            sectionHelper.visible = isSectionView;
            
            // Toggle fluid visibility based on section view
            components.fluidFlowSteam.visible = isSectionView;
            components.fluidFlowCondensate.visible = isSectionView;
            components.fluidFlowCoolingWater.visible = isSectionView;
            components.fluidFlowAir.visible = isSectionView;

            scene.traverse(child => {
                if (child.isMesh) {
                    // Apply clipping planes only to components that are part of the main assembly
                    if (child.parent && child.parent.userData.type === 'fullAssembly' || child.userData.type) { // Apply to all defined components
                         child.material.clippingPlanes = isSectionView ? [sectionPlane] : null;
                    } else {
                        child.material.clippingPlanes = null;
                    }
                    child.material.needsUpdate = true;
                }
            });
            
            document.getElementById('section-view').textContent = 
                isSectionView ? 'Full View' : 'Section View';
        }

        // Handle mouse clicks
        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Calculate objects intersecting the ray
            const intersects = raycaster.intersectObjects(scene.children, true); // true for recursive check
            
            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                // Traverse up the hierarchy to find the main component group
                while (clickedObject && !clickedObject.userData.type && clickedObject.parent) {
                    clickedObject = clickedObject.parent;
                }
                
                if (clickedObject && clickedObject.userData.type) {
                    const componentType = clickedObject.userData.type;
                    showOnly(componentType);
                }
            }
        }

        // Set up UI controls
        document.getElementById('toggle-casing').addEventListener('click', toggleCasingTransparency);
        document.getElementById('section-view').addEventListener('click', toggleSectionView);
        document.getElementById('reset-view').addEventListener('click', () => showOnly('full'));
        document.getElementById('view-casing').addEventListener('click', () => showOnly('casing'));
        document.getElementById('view-coil-bundle').addEventListener('click', () => showOnly('coilBundle'));
        document.getElementById('view-spray-system').addEventListener('click', () => showOnly('spraySystem'));
        document.getElementById('view-sump').addEventListener('click', () => showOnly('sump'));
        document.getElementById('view-fans').addEventListener('click', () => showOnly('fans'));
        document.getElementById('view-eliminators').addEventListener('click', () => showOnly('eliminators'));
        document.getElementById('view-steam-inlet').addEventListener('click', () => showOnly('steamInlet'));
        document.getElementById('view-condensate-outlet').addEventListener('click', () => showOnly('condensateOutlet'));

        window.addEventListener('click', onMouseClick, false);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate); // Request next frame
            controls.update(); // Update orbit controls

            // Animate steam particles
            if (components.fluidFlowSteam.visible) {
                const steamParticles = components.fluidFlowSteam.children[0];
                const steamPositions = steamParticles.geometry.attributes.position.array;
                const steamPath = steamParticles.userData.paths[0]; 

                for (let i = 0; i < steamParticles.userData.progress.length; i++) {
                    steamParticles.userData.progress[i] = (steamParticles.userData.progress[i] + 0.005) % 1; 
                    const p = steamPath.getPointAt(steamParticles.userData.progress[i]);
                    steamPositions[i * 3] = p.x + (Math.random() - 0.5) * 0.5; 
                    steamPositions[i * 3 + 1] = p.y + (Math.random() - 0.5) * 0.5;
                    steamPositions[i * 3 + 2] = p.z + (Math.random() - 0.5) * 0.5;
                }
                steamParticles.geometry.attributes.position.needsUpdate = true;
            }

            // Animate condensate particles
            if (components.fluidFlowCondensate.visible) {
                const condensateParticles = components.fluidFlowCondensate.children[0];
                const condensatePositions = condensateParticles.geometry.attributes.position.array;
                const condensatePath = condensateParticles.userData.paths[0]; 

                for (let i = 0; i < condensateParticles.userData.progress.length; i++) {
                    condensateParticles.userData.progress[i] = (condensateParticles.userData.progress[i] + 0.003) % 1; 
                    const p = condensatePath.getPointAt(condensateParticles.userData.progress[i]);
                    condensatePositions[i * 3] = p.x;
                    condensatePositions[i * 3 + 1] = p.y;
                    condensatePositions[i * 3 + 2] = p.z;
                }
                condensateParticles.geometry.attributes.position.needsUpdate = true;
            }

            // Animate cooling water particles (spraying and falling)
            if (components.fluidFlowCoolingWater.visible) {
                const coolingWaterParticles = components.fluidFlowCoolingWater.children[0];
                const coolingWaterPositions = coolingWaterParticles.geometry.attributes.position.array;
                const coolingWaterPath = coolingWaterParticles.userData.paths[0]; 

                for (let i = 0; i < coolingWaterParticles.userData.progress.length; i++) {
                    coolingWaterParticles.userData.progress[i] = (coolingWaterParticles.userData.progress[i] + 0.008) % 1; 
                    const p = coolingWaterPath.getPointAt(coolingWaterParticles.userData.progress[i]);
                    coolingWaterPositions[i * 3] = p.x + (Math.random() - 0.5) * 0.5; // Spread out more for spray
                    coolingWaterPositions[i * 3 + 1] = p.y;
                    coolingWaterPositions[i * 3 + 2] = p.z + (Math.random() - 0.5) * 0.5;
                }
                coolingWaterParticles.geometry.attributes.position.needsUpdate = true;
            }

            // Animate air particles (entering, moving through, exiting)
            if (components.fluidFlowAir.visible) {
                const airParticles = components.fluidFlowAir.children[0];
                const airPositions = airParticles.geometry.attributes.position.array;
                const numAirParticles = airParticles.userData.progress.length;
                const airInletY = components.sump.position.y + sumpHeight / 2 + 1; // Just above sump
                const airOutletY = components.fans.children[0].position.y - fanHeight / 2; // Below fans

                for (let i = 0; i < numAirParticles; i++) {
                    airPositions[i * 3 + 1] += 0.2; // Move upwards

                    if (airPositions[i * 3 + 1] > airOutletY) {
                        // Reset particle to bottom inlet
                        airPositions[i * 3] = (Math.random() * casingWidth * 0.8) - (casingWidth * 0.4);
                        airPositions[i * 3 + 1] = airInletY + Math.random() * 2; 
                        airPositions[i * 3 + 2] = (Math.random() * casingLength * 0.8) - (casingLength * 0.4);
                    }
                    // Add slight horizontal drift for realism
                    airPositions[i * 3] += (Math.random() - 0.5) * 0.1;
                    airPositions[i * 3 + 2] += (Math.random() - 0.5) * 0.1;

                    // Keep within casing boundaries (simplified)
                    airPositions[i * 3] = Math.max(-casingWidth * 0.4, Math.min(casingWidth * 0.4, airPositions[i * 3]));
                    airPositions[i * 3 + 2] = Math.max(-casingLength * 0.4, Math.min(casingLength * 0.4, airPositions[i * 3 + 2]));
                }
                airParticles.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera); // Render the scene
        }
        
        // Start the animation on window load.
        window.onload = function () {
            animate(); 
        }
    </script>
</body>
</html>
